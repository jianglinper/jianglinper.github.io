<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/07/07/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="为什么要学JavaScript"><a href="#为什么要学JavaScript" class="headerlink" title="为什么要学JavaScript?"></a>为什么要学JavaScript?</h1><ol>
<li>表单验证－减轻服务器端压力</li>
<li>页面动态效果</li>
</ol>
<span id="more"></span>

<h1 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript"></a>什么是JavaScript</h1><ol>
<li><strong>JavaScript</strong>是一种基于对象和事件驱动的、并具有安全性能的<strong>脚本语言</strong></li>
</ol>
<h1 id="JavaScript特点"><a href="#JavaScript特点" class="headerlink" title="JavaScript特点"></a>JavaScript特点</h1><ol>
<li>向HTML页面中添加交互行为</li>
<li>脚本语言，语法和Java类似</li>
<li>解释性语言，边执行边解释</li>
</ol>
<h1 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h1><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511846.png" alt="JavaScript组成"></p>
<h1 id="JavaScript的基本结构"><a href="#JavaScript的基本结构" class="headerlink" title="JavaScript的基本结构"></a>JavaScript的基本结构</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    &lt;!—</span><br><span class="line">          JavaScript 语句;</span><br><span class="line">    —&gt;</span><br><span class="line">&lt;/script &gt;</span><br></pre></td></tr></table></figure>

<script>…</script>可以包含在文档中的任何地方，只要保证这些代码在被使用前已读取并加载到内存即可

<h1 id="网页中引用JavaScript的方式"><a href="#网页中引用JavaScript的方式" class="headerlink" title="网页中引用JavaScript的方式"></a>网页中引用JavaScript的方式</h1><ol>
<li><p>行内：使用  script&gt;标签</p>
</li>
<li><p>外部：外部JS文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;export.js&quot;</span>  type=<span class="string">&quot;text/javascript&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">//记住这是导入js和直接写不一样</span></span><br></pre></td></tr></table></figure></li>
<li><p>内部: 直接在HTML标签中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;btn&quot;</span> type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;弹出消息框&quot;</span>   </span><br><span class="line">   onclick=<span class="string">&quot;javascript:alert(&#x27;欢迎你&#x27;);&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="JavaScript核心语法"><a href="#JavaScript核心语法" class="headerlink" title="JavaScript核心语法"></a>JavaScript核心语法</h1><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511869.png" alt="JavaScript核心语法"></p>
<h2 id="核心语法—变量"><a href="#核心语法—变量" class="headerlink" title="核心语法—变量"></a>核心语法—变量</h2><ol>
<li><h3 id="先声明变量再赋值"><a href="#先声明变量再赋值" class="headerlink" title="先声明变量再赋值"></a>先声明变量再赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>   width;	<span class="comment">//var －  用于声明变量的关键字</span></span><br><span class="line">width = <span class="number">5</span>;		<span class="comment">//width － 变量名</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="同时声明和赋值变量"><a href="#同时声明和赋值变量" class="headerlink" title="同时声明和赋值变量"></a>同时声明和赋值变量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> catName= <span class="string">&quot;皮皮&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x, y, z = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="不声明直接赋值"><a href="#不声明直接赋值" class="headerlink" title="不声明直接赋值"></a>不声明直接赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">width=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>变量可以不经声明而直接使用，但这种方法很容易出错，也很难查找排错，不推荐使用</strong></p>
</li>
<li><h3 id="核心语法—数据类型"><a href="#核心语法—数据类型" class="headerlink" title="核心语法—数据类型"></a>核心语法—数据类型</h3><ol>
<li><strong>undefined</strong><ul>
<li><strong>var width;</strong>  变量width没有初始值，将被赋予值<strong>undefined</strong></li>
</ul>
</li>
<li><strong>null</strong><ul>
<li>表示一个空值，与<strong>undefined</strong>值相等</li>
</ul>
</li>
<li><strong>number</strong><ul>
<li><strong>var</strong> <strong>iNum</strong>**=23;  //整数</li>
<li>var** <strong>iNum</strong><strong>=23.0;  //浮点数</strong></li>
</ul>
</li>
<li><strong>boolean</strong><ul>
<li><strong>true</strong>和<strong>false</strong></li>
</ul>
</li>
<li><strong>string</strong><ul>
<li><strong>一组被引号（单引号或双引号）括起来的文本</strong></li>
<li><em>var</em>* <strong>string1=”This is a string”;</strong></li>
</ul>
</li>
</ol>
</li>
<li><h3 id="核心语法—-typeof运算符"><a href="#核心语法—-typeof运算符" class="headerlink" title="核心语法— typeof运算符"></a>核心语法— typeof运算符</h3><ul>
<li><strong>typeof</strong>检测变量的返回值</li>
<li><strong>typeof</strong>：运算符返回值如下<ul>
<li><strong>undefined</strong>：变量被声明后，但未被赋值</li>
<li><strong>string</strong>：用单引号或双引号来声明的字符串</li>
<li><strong>boolean</strong>：<strong>true</strong>或<strong>false</strong></li>
<li><strong>number</strong>：整数或浮点数**</li>
<li><strong>object****：</strong>javascript**中的对象、数组和null</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="核心语法—String对象"><a href="#核心语法—String对象" class="headerlink" title="核心语法—String对象"></a>核心语法—String对象</h3><ul>
<li>属性</li>
</ul>
<ol>
<li>字符串对象**.length**</li>
<li><strong>方法</strong></li>
<li>字符串对象.方法名();</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;this is JavaScript&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> strLength=str.length;    <span class="comment">//长度是18</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>charAt(index)</td>
<td>返回在指定位置的字符</td>
</tr>
<tr>
<td>indexOf(str，index)</td>
<td>查找某个指定的字符串在字符串中首次出现的位置</td>
</tr>
<tr>
<td>substring(index1，index2)</td>
<td>返回位于指定索引index1和index2之间的字符串，并且包括索引index1对应的字符，不包括索引index2对应的字符</td>
</tr>
<tr>
<td>split(str)</td>
<td>将字符串分割为字符串数组</td>
</tr>
</tbody></table>
</li>
<li><h3 id="核心语法—数组"><a href="#核心语法—数组" class="headerlink" title="核心语法—数组"></a>核心语法—数组</h3><ol>
<li><p>创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  数组名称 = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line"><span class="comment">//new 表示数组的关键字</span></span><br><span class="line"><span class="comment">//size表示数组中可存放的元素总数</span></span><br></pre></td></tr></table></figure></li>
<li><p>为数组元素赋值</p>
</li>
<li><p>访问数组</p>
</li>
<li><p>数组的常用属性和方法</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>属性</td>
<td><strong>length</strong></td>
<td>设置或返回数组中元素的数目</td>
</tr>
<tr>
<td>方法</td>
<td><strong>join( )</strong></td>
<td>把数组的所有元素放入一个字符串，通过一个的分隔符进行分隔</td>
</tr>
<tr>
<td>方法</td>
<td><strong>sort()</strong></td>
<td>对数组排序</td>
</tr>
<tr>
<td>方法</td>
<td><strong>push()</strong></td>
<td>向数组末尾添加一个或更多 元素，并返回新的长度</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h3 id="核心语法—运算符号-和Java类似"><a href="#核心语法—运算符号-和Java类似" class="headerlink" title="核心语法—运算符号-和Java类似"></a>核心语法—运算符号-和Java类似</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td><strong>算术运算符</strong></td>
<td><strong>+</strong>  <strong>-</strong>  *****  <strong>/</strong>  <strong>%</strong>  <strong>++</strong>  <strong>—</strong></td>
</tr>
<tr>
<td><strong>赋值运算符</strong></td>
<td><strong>=</strong>  <strong>+=</strong>  <strong>-=</strong></td>
</tr>
<tr>
<td><strong>比较运算符</strong></td>
<td><strong>&gt;</strong>  <strong>&lt;**   **&gt;=</strong>   <strong>&lt;=</strong>   <strong>==</strong>  <strong>!=  ===</strong>  <strong>!==</strong></td>
</tr>
<tr>
<td><strong>逻辑运算符</strong></td>
<td><strong>&amp;&amp;</strong>    <strong>||</strong>   <strong>!</strong></td>
</tr>
</tbody></table>
</li>
<li><h3 id="核心语法—逻辑控制语句"><a href="#核心语法—逻辑控制语句" class="headerlink" title="核心语法—逻辑控制语句"></a>核心语法—逻辑控制语句</h3><ol>
<li><p><strong>if</strong>条件语句-和Java一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//JavaScript代码;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//JavaScript代码;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>switch</strong>多分支语句-和Java一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;    <span class="keyword">case</span> 常量<span class="number">1</span> : </span><br><span class="line">              JavaScript语句<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> 常量<span class="number">2</span> : </span><br><span class="line"> 	JavaScript语句<span class="number">2</span>;</span><br><span class="line"> 	<span class="keyword">break</span>;</span><br><span class="line">         ...</span><br><span class="line">        <span class="attr">default</span> : </span><br><span class="line">             JavaScript语句<span class="number">3</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>for、while</strong>循环语句-和Java一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;  条件;  增量)</span><br><span class="line"> &#123;</span><br><span class="line">      JavaScript代码; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(条件)</span><br><span class="line"> &#123;</span><br><span class="line">      JavaScript代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>for-in</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruit=[ <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;peach&quot;</span>,<span class="string">&quot;banana&quot;</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> fruit)&#123;<span class="comment">//循环的是下标 i是下标</span></span><br><span class="line">       <span class="built_in">document</span>.write(fruit[i]+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="核心语法—循环中断-和Java一样"><a href="#核心语法—循环中断-和Java一样" class="headerlink" title="核心语法—循环中断-和Java一样"></a>核心语法—循环中断-和Java一样</h3><ol>
<li><p><strong>break</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;这个数字是：&quot;</span>+i+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>continue</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;这个数字是：&quot;</span>+i+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="核心语法—注释-和Java一样"><a href="#核心语法—注释-和Java一样" class="headerlink" title="核心语法—注释-和Java一样"></a>核心语法—注释-和Java一样</h3><ol>
<li><p>单行注释以 // 开始，以行末结束</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;恭喜你！注册会员成功&quot;</span>); <span class="comment">//在页同上弹出注册会员成功的提示框</span></span><br></pre></td></tr></table></figure></li>
<li><p>多行注释以 /* 开始，以 */ 结束，符号 /*…… */ 指示中间的语句是该程序中的注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用for循环运行“document.write(&quot;&lt;h3&gt;Hello World&lt;/h3&gt;&quot;);”5次</span></span><br><span class="line"><span class="comment">使用document.write在页面上输出“Hello World” </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="核心语法—常用的输入-输出"><a href="#核心语法—常用的输入-输出" class="headerlink" title="核心语法—常用的输入/输出"></a>核心语法—常用的输入/输出</h3><ol>
<li><p><strong>alert()</strong></p>
<ul>
<li>alert()方法是显示一条弹出提示消息和确认按钮的警告框。</li>
<li>需要注意的是 ：alert()是一个阻塞的函数，如果我们不点确认按钮，后面的内容就不会加载出来。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;想要提示的文本内容&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>confirm()</strong></p>
<ul>
<li><strong>confirm()方法是显示一个含有指定消息和确认和取消按钮的确认框。</strong></li>
<li><strong>如果点击”确定”返回true，否则返回false。</strong></li>
</ul>
<p>不接收返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">confirm(<span class="string">&quot;这样写可以直接显示,不接收返回值。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接收返回值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x; </span><br><span class="line"><span class="keyword">var</span> r=confirm(<span class="string">&quot;请按下按钮!&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r==<span class="literal">true</span>)&#123;</span><br><span class="line">	x=<span class="string">&quot;你按下的是\&quot;确定\&quot;按钮。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	x=<span class="string">&quot;你按下的是\&quot;取消\&quot;按钮。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(x)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>prompt ()</strong></p>
<ul>
<li><strong>prompt()方法是显示提示用户进行输入的对话框。</strong></li>
<li><strong>这个方法返回的是用户输入的字符串。</strong></li>
</ul>
<p>不显示默认文本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">prompt(<span class="string">&quot;开心吗?&quot;</span>); <span class="comment">// 这个显示内容也可以不写，但就没有交互的意义了。</span></span><br></pre></td></tr></table></figure>

<p>显示默认文本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x; </span><br><span class="line"><span class="keyword">var</span> name=prompt(<span class="string">&quot;请输入你的名字&quot;</span>,<span class="string">&quot;Keafmd&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (name!=<span class="literal">null</span> &amp;&amp; person!=<span class="string">&quot;&quot;</span>)&#123; </span><br><span class="line"> x=<span class="string">&quot;你好! &quot;</span> + name + <span class="string">&quot;。&quot;</span>;</span><br><span class="line"> <span class="built_in">document</span>.write(x)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="核心语法—语法约定-和Java一样"><a href="#核心语法—语法约定-和Java一样" class="headerlink" title="核心语法—语法约定-和Java一样"></a>核心语法—语法约定-和Java一样</h3><ol>
<li><strong>代码区分大小写</strong></li>
<li><strong>变量、对象和函数的名称</strong></li>
<li><strong>分号</strong></li>
</ol>
</li>
</ol>
<h1 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a><strong>常用系统函数</strong></h1><ol>
<li><h3 id="parseInt-“字符串”"><a href="#parseInt-“字符串”" class="headerlink" title="parseInt (“字符串”)"></a>parseInt (“字符串”)</h3><ul>
<li><p>将字符串转换为整型数字 </p>
<p>如: parseInt (“86”)将字符串“86“转换为整型值86</p>
</li>
<li><p>parseInt()函数首先查看位置0处的字符,判断它是否为一个有效数字,如果不是则返回NaN,不在继续执行其他操作.但如果该字符是有效数字,则该函数讲查看位置1处的字符,进行同样的测试,这一过程将持续到发现非有效数字的字符为止,此时parseInt()将该字符之前的字符串转换成数字例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="built_in">parseInt</span>(<span class="string">&quot;78.89&quot;</span>);			<span class="comment">//返回值为78</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="built_in">parseInt</span>(<span class="string">&quot;4567color&quot;</span>);		<span class="comment">//返回值为4567</span></span><br><span class="line"><span class="keyword">var</span> num3=<span class="built_in">parseInt</span>(<span class="string">&quot;this36&quot;</span>);		<span class="comment">//返回值为NaN</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="parseFloat-“字符串”"><a href="#parseFloat-“字符串”" class="headerlink" title="parseFloat(“字符串”)"></a>parseFloat(“字符串”)</h3><ul>
<li><p>将字符串转换为浮点型数字<br>如: parseFloat(“34.45”)将字符串“34.45“转换为浮点值34.45]</p>
</li>
<li><p>parseFloat()函数和parseInt ()函数的处理方式相似,从位置为0开始查看每个字符,直到找到第一个非有效数字为止,然后把该字符之前的字符串转换成浮点数.</p>
</li>
<li><p>对于这个函数来说,第一个出现的小数点是有效字符,如果有两个小数点,那么第二个小数点被看做无效.例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1=<span class="built_in">parseFloat</span>(<span class="string">&quot;4567color&quot;</span>);		<span class="comment">//返回值为4567</span></span><br><span class="line"><span class="keyword">var</span> num2=<span class="built_in">parseFloat</span>(<span class="string">&quot;45.58&quot;</span>);			<span class="comment">//返回值为45.58</span></span><br><span class="line"><span class="keyword">var</span> num3=<span class="built_in">parseFloat</span>(<span class="string">&quot;45.58.25&quot;</span>);		<span class="comment">//返回值为45.58</span></span><br><span class="line"><span class="keyword">var</span> num4=<span class="built_in">parseFloat</span>(<span class="string">&quot;color4567&quot;</span>);		<span class="comment">//返回值为NaN</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p>用于检查其参数是否是非数字 如果是非数字值,返回true 如果是非数值,返回flase 例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag1=<span class="built_in">isNaN</span>(<span class="string">&quot;12.5&quot;</span>);		<span class="comment">//返回值false</span></span><br><span class="line"><span class="keyword">var</span> flag2=<span class="built_in">isNaN</span>(<span class="string">&quot;12.5s&quot;</span>);		<span class="comment">//返回值true</span></span><br><span class="line"><span class="keyword">var</span> flag3=<span class="built_in">isNaN</span>(<span class="string">&quot;45.8&quot;</span>);		<span class="comment">//返回值false</span></span><br></pre></td></tr></table></figure>

<p>isNaN()函数通常用于监测parseFloat()和parseInt ()的结果,以判断它们表示的是否合法的数字.也可以用isNaN()函数来检测算数是否错误,如用0作为除数的情况.</p>
</li>
</ol>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>同java一样,JavaScript需要先定义函数,然后才能调用函数.</p>
<ol>
<li><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在JavaScript中,自定义函数由关键字<strong>function</strong>,函数名,一组参数及置于括号中的待执行的JavaScript语句组成,语法格式如下.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3</span>, … </span>)</span>&#123;</span><br><span class="line">     <span class="comment">//JavaScript语句</span></span><br><span class="line">     [<span class="keyword">return</span> 返回值]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>function是定义函数的关键字,必须有</p>
</li>
<li><p>参数1,参数2,等是函数的参数.因为JavaScript本身是弱类型,所以他的参数也没有类型检查和类型限定.函数中的参数是可选的,根据函数是否可带参数,可分为不带参数的无参函数和有参函数.例如,有参函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//JavaScript 语句;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>“{“和”}”定义了函数的开始和结束</p>
</li>
<li><p>return语句来规定函数返回的值.</p>
</li>
</ul>
</li>
<li><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>要执行一个函数,必须先调用这个函数,当调用函数时,必须制定函数名及其后面的参数(如果有参数).函数的调用一般和元素的事件结合使用.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">事件名=<span class="string">&quot;函数名()&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onload</td>
<td>一个页面或一幅图像完成加载</td>
</tr>
<tr>
<td>onlick</td>
<td>鼠标单击某个对象</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标指导移到某元素上</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键被按下</td>
</tr>
<tr>
<td>onchange</td>
<td>域的内容被改变</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131512661.png" alt="JavaScript基础总结"></p>
]]></content>
      <categories>
        <category>使用jQuery快速高效制作网页交互特效</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript操作BOM对象</title>
    <url>/2021/07/11/JavaScript%E6%93%8D%E4%BD%9CBOM%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="BOM模型"><a href="#BOM模型" class="headerlink" title="BOM模型"></a>BOM模型</h1><ol>
<li><p>BOM：浏览器对象模型（Browser Object Model）</p>
</li>
<li><p>BOM提供了独立于内容的、可以与浏览器窗口进行互动的对象结构</p>
<span id="more"></span></li>
</ol>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511906.png" alt="image-20210711112651203"></p>
<ol start="3">
<li>BOM可实现功能<ol>
<li>弹出新的浏览器窗口</li>
<li>移动、关闭浏览器窗口以及调整窗口的大小</li>
<li>页面的前进、后退</li>
</ol>
</li>
</ol>
<h1 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h1><ol>
<li><h2 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h2><table>
<thead>
<tr>
<th>属性名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>history</strong></td>
<td>有关客户访问过的URL的信息</td>
</tr>
<tr>
<td><strong>location</strong></td>
<td>有关当前 URL 的信息</td>
</tr>
</tbody></table>
<p>​    语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.属性名= <span class="string">&quot;属性值&quot;</span> </span><br></pre></td></tr></table></figure>

<p>​    示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.location=<span class="string">&quot;http://www.bdqn.cn&quot;</span> ;      <span class="comment">//表示跳转到北大青鸟首页</span></span><br></pre></td></tr></table></figure></li>
<li><h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>prompt( )</strong></td>
<td>显示可提示用户输入的对话框</td>
</tr>
<tr>
<td><strong>alert( )</strong></td>
<td>显示带有一个提示信息和一个确定按钮的警示框</td>
</tr>
<tr>
<td><strong>confirm( )</strong></td>
<td>显示一个带有提示信息、确定和取消按钮的对话框</td>
</tr>
<tr>
<td><strong>close( )</strong></td>
<td>关闭浏览器窗口</td>
</tr>
<tr>
<td><strong>open( )</strong></td>
<td>打开一个新的浏览器窗口，加载给定 URL 所指定的文档</td>
</tr>
<tr>
<td><strong>setTimeout( )</strong></td>
<td>在指定的毫秒数后调用函数或计算表达式</td>
</tr>
<tr>
<td><strong>setInterval()</strong></td>
<td>按照指定的周期（以毫秒计）来调用函数或表达式</td>
</tr>
</tbody></table>
<ol>
<li><h3 id="confirm-方法"><a href="#confirm-方法" class="headerlink" title="confirm()方法"></a>confirm()方法</h3><ol>
<li>confirm()：将弹出一个确认对话框</li>
<li>confirm()与alert ()、 prompt()区别<ol>
<li>alert( )：一个参数，仅显示警告对话框的消息，无返回值，不能对脚本产生任何改变</li>
<li>prompt( )：两个参数，输入对话框，用来提示用户输入一些信息，单击“取消”按钮则返回null，击“确定”按钮则返回用户输入的值，常用于收集用户关于特定问题而反馈的信息</li>
<li>confirm( )：一个参数，确认对话框，显示提示对话框的消息、“确定”按钮和“取消”按钮，单击“定”按钮返回true，单击“取消”按钮返回false，因此与if-else语句搭配使用</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">confirm(<span class="string">&quot;对话框中显示的纯文本&quot;</span>)</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   <span class="keyword">var</span> flag=confirm(<span class="string">&quot;确认要删除此条信息吗？&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">true</span>)</span><br><span class="line">	      alert(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	       alert(<span class="string">&quot;你取消了删除&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h3><ol>
<li><p>窗口特征</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>说   明</th>
</tr>
</thead>
<tbody><tr>
<td>height、width</td>
<td>窗口文档显示区的高度、宽度。以像素计</td>
</tr>
<tr>
<td>left、top</td>
<td>窗口的x坐标、y坐标。以像素计</td>
</tr>
<tr>
<td>toolbar=yes |no |1 |0</td>
<td>是否显示浏览器的工具栏。黙认是yes</td>
</tr>
<tr>
<td>scrollbars=yes |no |1 |0</td>
<td>是否显示滚动条。黙认是yes</td>
</tr>
<tr>
<td>location=yes |no |1 |0</td>
<td>是否显示地址地段。黙认是yes</td>
</tr>
<tr>
<td>status=yes |no |1 |0</td>
<td>是否添加状态栏。黙认是yes</td>
</tr>
<tr>
<td>menubar=yes |no |1 |0</td>
<td>是否显示菜单栏。黙认是yes</td>
</tr>
<tr>
<td>resizable=yes |no |1 |0</td>
<td>窗口是否可调节尺寸。黙认是yes</td>
</tr>
<tr>
<td>titlebar=yes |no |1 |0</td>
<td>是否显示标题栏。黙认是yes</td>
</tr>
<tr>
<td>fullscreen=yes |no |1 |0</td>
<td>是否使用全屏模式显示浏览器。黙认是no。<br>处于全屏模式的窗口必须同时处于剧院模式</td>
</tr>
</tbody></table>
<p>语法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&quot;弹出窗口的url&quot;</span>,<span class="string">&quot;窗口名称&quot;</span>,<span class="string">&quot;窗口特征”)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ol>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>加载 history 对象列表中的前一个URL</td>
</tr>
<tr>
<td>forward()</td>
<td>加载 history 对象列表中的下一个URL</td>
</tr>
<tr>
<td>go()</td>
<td>加载 history 对象列表中的某个具体URL</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.back()		<span class="comment">/*等价于*/</span>		history.go(-<span class="number">1</span>)	<span class="comment">//浏览器中的后退</span></span><br><span class="line">history.forward()	<span class="comment">/*等价于*/</span>		history.go(<span class="number">1</span>)	<span class="comment">//浏览器中的后退</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ol>
<li><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>设置或返回主机名和当前URL的端口号</td>
</tr>
<tr>
<td>hostname</td>
<td>设置或返回当前URL的主机名</td>
</tr>
<tr>
<td>href</td>
<td>设置或返回完整的URL</td>
</tr>
</tbody></table>
</li>
<li><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>reload()</td>
<td>重新加载当前文档</td>
</tr>
<tr>
<td>replace()</td>
<td>用新的文档替换当前文档</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><h2 id="location和history对象的应用"><a href="#location和history对象的应用" class="headerlink" title="location和history对象的应用"></a>location和history对象的应用</h2><ol>
<li><p>主页面使用href实现跳转和刷新本页</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:location.href=&#x27;flower.html&#x27;&quot;</span>&gt;查看鲜花详情&lt;/a&gt;  </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:location.reload()&quot;</span>&gt;</span>刷新本页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:history.back()&quot;</span>&gt;</span>返回主页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h1><ol>
<li><h3 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>referrer</strong></td>
<td>返回载入当前文档的URL</td>
</tr>
<tr>
<td><strong>URL</strong></td>
<td>返回当前文档的URL</td>
</tr>
</tbody></table>
<p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.referrer</span><br><span class="line"><span class="built_in">document</span>.URL</span><br></pre></td></tr></table></figure>

<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511775.png" alt="image-20210711114644954"></p>
</li>
<li><h3 id="Document对象应用"><a href="#Document对象应用" class="headerlink" title="Document对象应用"></a>Document对象应用</h3><ol>
<li><p>判断页面是否是链接进入</p>
</li>
<li><p>自动跳转到登录页面</p>
</li>
<li><p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preUrl=<span class="built_in">document</span>.referrer;  <span class="comment">//载入本页面文档的地址</span></span><br><span class="line"><span class="keyword">if</span>(preUrl==<span class="string">&quot;&quot;</span>)&#123;	</span><br><span class="line">      <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h2&gt;您不是从领奖页面进入，5秒后将自动 </span></span><br><span class="line"><span class="string">                         跳转到登录页面&lt;/h2&gt;&quot;</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="string">&quot;javascript:location.href=&#x27;login.html&#x27;&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="Document对象的常用方法"><a href="#Document对象的常用方法" class="headerlink" title="Document对象的常用方法"></a>Document对象的常用方法</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>getElementById()</td>
<td>返回对拥有指定id的第一个对象的引用</td>
<td><strong>对象的id唯一</strong></td>
</tr>
<tr>
<td>getElementsByName()</td>
<td>返回带有指定名称的对象的数组</td>
<td>相同name属性</td>
</tr>
<tr>
<td>getElementsByTagName()</td>
<td>返回带有指定标签名的对象的数组</td>
<td><strong>相同的元素</strong></td>
</tr>
<tr>
<td>write()</td>
<td>向文档写文本、HTML表达式或JavaScript代码</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><p>动态改变层、标签中的内容</p>
</li>
<li><p>访问相同name的元素</p>
</li>
<li><p>访问相同标签的元素</p>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;book&quot;</span>).innerHTML=<span class="string">&quot;现象级全球畅销书&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aInput=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sStr=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;aInput.length;i++)&#123;</span><br><span class="line">       sStr+=aInput[i].value+<span class="string">&quot;&amp;nbsp;&amp;nbsp;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;replace&quot;</span>).innerHTML=sStr;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="JavaScript内置对象"><a href="#JavaScript内置对象" class="headerlink" title="JavaScript内置对象"></a>JavaScript内置对象</h1><ol>
<li>Array：用于在单独的变量名中存储一系列的值</li>
<li>String：用于支持对字符串的处理</li>
<li>Math：用于执行常用的数学任务，它包含了若干个数字常量和函数</li>
<li>Date：用于操作日期和时间</li>
</ol>
<ol>
<li><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2></li>
</ol>
<p>使用Date对象获得时、分、秒</p>
<ol start="2">
<li><h2 id="Date对象的方法"><a href="#Date对象的方法" class="headerlink" title="Date对象的方法"></a>Date对象的方法</h2></li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>getDate()</strong></td>
<td>返回 Date 对象的一个月中的每一天，其值介于1～31之间</td>
</tr>
<tr>
<td><strong>getDay()</strong></td>
<td>返回 Date 对象的星期中的每一天，其值介于0～6之间</td>
</tr>
<tr>
<td><strong>getHours()</strong></td>
<td>返回 Date 对象的小时数，其值介于0～23之间</td>
</tr>
<tr>
<td><strong>getMinutes()</strong></td>
<td>返回 Date 对象的分钟数，其值介于0～59之间</td>
</tr>
<tr>
<td><strong>getSeconds()</strong></td>
<td>返回 Date 对象的秒数，其值介于0～59之间</td>
</tr>
<tr>
<td><strong>getMonth()</strong></td>
<td>返回 Date 对象的月份，其值介于0～11之间</td>
</tr>
<tr>
<td><strong>getFullYear()</strong></td>
<td>返回 Date 对象的年份，其值为4位数</td>
</tr>
<tr>
<td><strong>getTime()</strong></td>
<td>返回自某一时刻（1970年1月1日）以来的毫秒数</td>
</tr>
</tbody></table>
<ol start="3">
<li><h2 id="制作时钟特效"><a href="#制作时钟特效" class="headerlink" title="制作时钟特效"></a>制作时钟特效</h2></li>
</ol>
<p>使用Date对象的方法显示当前时间的小时、分钟和秒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disptime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();  </span><br><span class="line"><span class="keyword">var</span> hh = today.getHours(); </span><br><span class="line"><span class="keyword">var</span> mm = today.getMinutes();</span><br><span class="line"><span class="keyword">var</span> ss = today.getSeconds();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myclock&quot;</span>).innerHTML=<span class="string">&quot;现在是:&quot;</span>+hh +<span class="string">&quot;:&quot;</span>+mm+<span class="string">&quot;: &quot;</span>+ss;</span><br><span class="line">&#125;</span><br><span class="line">disptime();</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myclock&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2></li>
</ol>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>ceil()</td>
<td>对数进行上舍入</td>
<td>Math.ceil(25.5);返回26  Math.ceil(-25.5);返回-25</td>
</tr>
<tr>
<td>floor()</td>
<td>对数进行下舍入</td>
<td>Math.floor(25.5);返回25  Math.floor(-25.5);返回-26</td>
</tr>
<tr>
<td>round()</td>
<td>把数四舍五入为最接近的数</td>
<td>Math.round(25.5);返回26  Math.round(-25.5);返回-26</td>
</tr>
<tr>
<td>random()</td>
<td>返回0~1之间的随机数</td>
<td>Math.random();例如：0.6273608814137365</td>
</tr>
</tbody></table>
<p>如何实现返回的整数范围为2~99？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">98</span>+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>随机选择颜色</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> color=<span class="built_in">Array</span>(<span class="string">&quot;红色&quot;</span>,<span class="string">&quot;黄色&quot;</span>,<span class="string">&quot;蓝色&quot;</span>,<span class="string">&quot;绿色&quot;</span>,<span class="string">&quot;橙色&quot;</span>,<span class="string">&quot;青色&quot;</span>,<span class="string">&quot;紫色&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> num=<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">7</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;color&quot;</span>).innerHTML=color[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li><h2 id="定时函数"><a href="#定时函数" class="headerlink" title="定时函数"></a>定时函数</h2></li>
<li><h3 id="setTimeout-和clearTimeout"><a href="#setTimeout-和clearTimeout" class="headerlink" title="**setTimeout()**和clearTimeout()"></a>**setTimeout()**和clearTimeout()</h3></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>()</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;调用的函数&quot;</span>,等待的毫秒数)</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  myTime＝<span class="built_in">setTimeout</span>(<span class="string">&quot;disptime() &quot;</span>, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;显示提示消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;timer()&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="built_in">setTimeout</span>(<span class="string">&quot;alert(&#x27;3 seconds&#x27;)&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">//1秒(1000毫秒)之后执行函数disptime()一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clearTimeout-解除定时函数"><a href="#clearTimeout-解除定时函数" class="headerlink" title="**clearTimeout()**解除定时函数"></a>**clearTimeout()**解除定时函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(setTimeOut()返回的ID值)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  myTime＝<span class="built_in">setTimeout</span>(<span class="string">&quot;disptime() &quot;</span>, <span class="number">1000</span> );</span><br><span class="line"><span class="built_in">clearTimeout</span>(myTime)；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="setInterval-和clearInterval"><a href="#setInterval-和clearInterval" class="headerlink" title="setInterval()和clearInterval ()"></a><strong>setInterval()<strong>和</strong>clearInterval ()</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;调用的函数&quot;</span>,间隔的毫秒数)</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  myTime＝<span class="built_in">setInterval</span>(<span class="string">&quot;disptime() &quot;</span>, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>

<p>如果要多次调用，使用setInterval()或者让disptime()自身再次调用setTimeout()</p>
<h3 id="clearInterval-解除定时函数"><a href="#clearInterval-解除定时函数" class="headerlink" title="clearInterval ()解除定时函数"></a>clearInterval ()解除定时函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearInterval</span>(<span class="built_in">setInterval</span>()返回的ID值)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  myTime＝<span class="built_in">setInterval</span>(<span class="string">&quot;disptime() &quot;</span>, <span class="number">1000</span> );</span><br><span class="line"><span class="built_in">clearInterval</span>(myTime)；</span><br></pre></td></tr></table></figure>

<h3 id="制作12进制的时钟特效"><a href="#制作12进制的时钟特效" class="headerlink" title="制作12进制的时钟特效"></a>制作12进制的时钟特效</h3><p>代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> timefinly = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> year = timefinly.getFullYear(); <span class="comment">//年</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> month = timefinly.getMonth() + <span class="number">1</span>; <span class="comment">//月</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> day = timefinly.getDate(); <span class="comment">//日</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> hour = timefinly.getHours(); <span class="comment">//时</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> APM = <span class="string">&quot;AM&quot;</span>;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">if</span> (hour &gt; <span class="number">12</span>) &#123;</span></span><br><span class="line"><span class="javascript">			APM = <span class="string">&quot;PM&quot;</span>;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> min = timefinly.getMinutes(); <span class="comment">//分</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> sec = timefinly.getSeconds(); <span class="comment">//秒</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> weekNum = timefinly.getDay(); <span class="comment">//周</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">if</span> (weekNum == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">			weekNum = <span class="number">7</span>;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> week=<span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">switch</span> (weekNum) &#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;一&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;二&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;三&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">4</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;四&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">5</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;五&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">6</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;六&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">case</span> <span class="number">7</span>:</span></span><br><span class="line"><span class="javascript">			week=<span class="string">&quot;日&quot;</span>;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> content = year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日     &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + min + <span class="string">&quot;:&quot;</span> + sec + <span class="string">&quot;     &quot;</span> + APM +</span></span><br><span class="line"><span class="javascript">			<span class="string">&quot;    星期&quot;</span> + week</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.getElementById(<span class="string">&quot;time&quot;</span>).innerText = content;</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript">	showTime();</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> atime = <span class="built_in">setInterval</span>(<span class="string">&quot;showTime()&quot;</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">	<span class="comment">//clearInterval(atime);</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511983.png" alt="image-20210714100816234"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>使用jQuery快速高效制作网页交互特效</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript操作DOM对象</title>
    <url>/2021/07/16/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>DOM是Document Object Model的缩写，即文档对象模型,是基于文档编程的一套API接口。</p>
<p>使用JavaScript操作DOM分为三个方面：DOM Core (核心) ，HTML-DOM和CSS-DOM。通过这些标准开发人员可以让网页真正动起来，动态得增加，修好，删除数据，使用户与计算机的交互更加便捷，交互也更加丰富，那么下面，大家就一起学习JavaScript操作DOM吧。</p>
<span id="more"></span>

<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511386.png" alt="image-20210716105304043"></p>
<ol>
<li><h1 id="节点和节点的关系"><a href="#节点和节点的关系" class="headerlink" title="节点和节点的关系"></a>节点和节点的关系</h1></li>
</ol>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511814.png" alt="image-20210716105352860"></p>
<p>HTML中的每个标签和元素都是一个节点,在DOM中是这样规定的.</p>
<ul>
<li>整个文档是一个文档节点</li>
<li>每个HTML标签是一个元素节点</li>
<li>包含在HTML元素中的文本是文本节点</li>
<li>每个HTML属性是一个属性节点</li>
<li>注释属于注释节点</li>
</ul>
<p>一个HTML文档是由各个不同的节点组成的.</p>
<p>使用父（parent）、子（child）和同胞（sibling）等术语来描述这些节点的层次关系，父节点拥有子节点，同级的子节点被称为同胞或兄弟节点，他们的关系如下</p>
<ul>
<li>在父节点树种，顶部节点被称为根（root），如&lt;HTML&gt;节点。</li>
<li>每个节点都有父节点，除了根（他没有父节点），如&lt;head&gt;和&lt;body&gt;的父节点都是&lt;HTML&gt;、文本节点“DOM应用”的父节点是&lt;p&gt;节点。</li>
<li>一个节点可以拥有任意数量的子节点，如&lt;body&gt;节点的子节点有&lt;img&gt;、&lt;h1&gt;和&lt;p&gt;。</li>
<li>同胞节点可以拥有任意数量的子节点，如&lt;img&gt;、&lt;h1&gt;和&lt;p&gt;就是兄弟节点，他们的父节点均为&lt;body&gt;节点。</li>
</ul>
<p>由于HTML文档中的标签，元素都是一个节点，并且各个节点之间都存在关系，因此JavaScript可以通过访问或改变节点的方式来改变页面的内容使用JavaScript操作JavaScript操作节点主要是访问节点，在文章中创建和增加节点，删除节点，替换节点，移机操作节点属性和样式等，</p>
<ol start="2">
<li><h1 id="访问节点"><a href="#访问节点" class="headerlink" title="访问节点"></a>访问节点</h1><ol>
<li><p>使用getElement系列方法访问指定节点</p>
<ol>
<li>getElementById（）：返回按id属性查找的第一个对象的引用</li>
<li>getElementsByName（）：返回按带有指定名称name查找的对象的借还，由于一个文档中可能会有多个同名节点（如复选框、单选按钮），因此返回的是元素数组。</li>
<li>getElementsByTagName（）：返回带有指定标签名，TagName查找的是对象的集合，由于一个文档中可能会有多个同类型的标签节点（如图片组，文本输入框，因此返回的元素数组。）</li>
</ol>
</li>
<li><h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>parentNode</td>
<td>返回节点的父节点</td>
</tr>
<tr>
<td>childNodes</td>
<td>返回子节点集合，childNodes[i]</td>
</tr>
<tr>
<td>firstChild</td>
<td>返回节点的第一个子节点，最普遍的用法是访问该元素的文本节点</td>
</tr>
<tr>
<td>lastChild</td>
<td>返回节点的最后一个子节点</td>
</tr>
<tr>
<td>nextSibling</td>
<td>下一个节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>上一个节点</td>
</tr>
</tbody></table>
</li>
<li><h2 id="element属性"><a href="#element属性" class="headerlink" title="element属性"></a>element属性</h2><table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>firstElementChild</td>
<td>返回节点的第一个子节点，最普遍的用法是访问该元素的文本节点</td>
</tr>
<tr>
<td>lastElementChild</td>
<td>返回节点的最后一个子节点</td>
</tr>
<tr>
<td>nextElementSibling</td>
<td>下一个节点</td>
</tr>
<tr>
<td>previousElementSibling</td>
<td>上一个节点</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oNext = oParent.nextElementSibling || oParent.nextSibling   </span><br><span class="line">oPre = oParent.previousElementSibling || oParent.previousSibling  </span><br><span class="line">oFirst = oParent. firstElementChild  ||  oParent.firstChild   </span><br><span class="line">oLast = oParent.lastElementChild || oParent.lastChild </span><br><span class="line"></span><br><span class="line">如果||前面有值，那变量就等于前面的，如果没有就等于后面的。</span><br></pre></td></tr></table></figure>

<p>非IE下由于会吧标签之间的空格，换行当成文本节点，因此为了准确的找到相应的元素，使用firstElementChild  lastElementChild  nextElementSibling  previousElementSibling  </p>
</li>
</ol>
</li>
<li><h1 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h1><p>节点是DOM层次结构中的任何类型对象的通用名称，每个节点都拥有包含着关于节点的某些信息的属性，</p>
<ul>
<li>nodeName（节点名称）</li>
<li>nodeValue（节点值）</li>
<li>nodeType（节点类型）</li>
</ul>
<ol>
<li><p>nodeName属性包含某个节点的名称，元素节点的nodeName是标签名吃，属性节点的nodeName是属性名称，文本节点的nodeName永远是#text，文档节点的nodeName永远是#document。</p>
</li>
<li><p>nodeValue节点值，对于文本节点，nodeValue属性包含文本；对于属性节点，nodeValue属性包含属性值；nodeValue属性对于文档节点和元素节点是不可用的。</p>
</li>
<li><p>nodeType属性可返回节点的类型，是一个只读属性，如返回的元素节点，文本节点，注释节点等。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>NodeType值</th>
</tr>
</thead>
<tbody><tr>
<td>元素element</td>
<td>1</td>
</tr>
<tr>
<td>属性attr</td>
<td>2</td>
</tr>
<tr>
<td>文本text</td>
<td>3</td>
</tr>
<tr>
<td>注释comments</td>
<td>8</td>
</tr>
<tr>
<td>文档document</td>
<td>9</td>
</tr>
</tbody></table>
</li>
<li><h1 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h1><ol>
<li><h2 id="操作节点的属性"><a href="#操作节点的属性" class="headerlink" title="操作节点的属性"></a>操作节点的属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getAttribute(<span class="string">&quot;属性名&quot;</span>);			<span class="comment">//用来获取属性的值</span></span><br><span class="line">setAttribute(<span class="string">&quot;属性名&quot;</span>,<span class="string">&quot;属性值&quot;</span>);	  <span class="comment">//用来设置属性的值</span></span><br></pre></td></tr></table></figure></li>
<li><h2 id="创建和插入节点"><a href="#创建和插入节点" class="headerlink" title="创建和插入节点"></a>创建和插入节点</h2><p>使用JavaScript操作DOM有很多方法可以创建或增加一个新节点</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createElement( tagName)</td>
<td>创建一个标签名为tagName的新元素节点</td>
</tr>
<tr>
<td>A.appendChild(  B)</td>
<td>把B节点追加至A节点的末尾</td>
</tr>
<tr>
<td>insertBefore(  A,B )</td>
<td>把A节点插入到B节点之前</td>
</tr>
<tr>
<td>cloneNode(deep)</td>
<td>复制某个指定的节点</td>
</tr>
</tbody></table>
<ul>
<li>insertBefore(  A,B )  中有两个参数。A是必选想，表示新插入的节点；B是可选项，表示新节点被插入B节点的前面。</li>
<li>cloneNode(deep)  中的参数deep为布尔值，若deep值为true，则复制改节点，及该节点的所有子节点，若deep值为false，则只复制该节点和其属性。</li>
</ul>
</li>
<li><h2 id="删除和替换节点"><a href="#删除和替换节点" class="headerlink" title="删除和替换节点"></a>删除和替换节点</h2><p>使用Core HTML删除和替换节点的方法：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>removeChild( node)</td>
<td>删除指定的节点</td>
</tr>
<tr>
<td>replaceChild( newNode, oldNode）</td>
<td>用其他的节点替换指定的节点</td>
</tr>
</tbody></table>
<p>方法  replaceChild( newNode, oldNode）中的两个参数，newNode是替换的新节点，oldNode是要替换的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delNode=<span class="built_in">document</span>.getElementById(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">delNode.parentNode.removeChild(delNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldNode=<span class="built_in">document</span>.getElementById(<span class="string">&quot;second&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> newNode=<span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">newNode.setAttribute(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;images/f03.jpg&quot;</span>);</span><br><span class="line">oldNode.parentNode.replaceChild(newNode,oldNode);</span><br></pre></td></tr></table></figure></li>
<li><h2 id="操作节点样式"><a href="#操作节点样式" class="headerlink" title="操作节点样式"></a>操作节点样式</h2><p>在JavaScript中，有两种方式可以动态的改变样式的属性，一种是使用样式的style属性，另一种是使用样式的className属性。</p>
<ol>
<li><h3 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h3><p>在HTML DOM中，style是一个对象，代表一个单独的样式声明，可通过应用样式的文档或元素访问style对象，使用style属性改变样式的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTML元素.style.样式属性＝<span class="string">&quot;值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;titles&quot;</span>).style.color=<span class="string">&quot;#ff0000&quot;</span>; </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;titles&quot;</span>).style.fontSize=<span class="string">&quot;25px &quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>style常用的属性</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background（背景）</td>
<td>backgroundColor</td>
<td>设置元素的背景颜色</td>
</tr>
<tr>
<td>background（背景）</td>
<td>backgroundImage</td>
<td>设置元素的背景图像</td>
</tr>
<tr>
<td>background（背景）</td>
<td>backgroundRepeat</td>
<td>设置是否及如何重复背景图像</td>
</tr>
<tr>
<td>text（文本）</td>
<td>fontSize</td>
<td>设置元素的字体大小</td>
</tr>
<tr>
<td>text（文本）</td>
<td>fontWeight</td>
<td>设置字体的粗细</td>
</tr>
<tr>
<td>text（文本）</td>
<td>textAlign</td>
<td>排列文本</td>
</tr>
<tr>
<td>text（文本）</td>
<td>textDecoration</td>
<td>设置文本的修饰</td>
</tr>
<tr>
<td>text（文本）</td>
<td>font</td>
<td>设置同一字体的属性</td>
</tr>
<tr>
<td>text（文本）</td>
<td>color</td>
<td>设置文本的颜色</td>
</tr>
<tr>
<td>padding（边距）</td>
<td>padding</td>
<td>设置元素的填充</td>
</tr>
<tr>
<td>padding（边距）</td>
<td>paddingTop<br>paddingBottom<br>paddingLeft<br>paddingRight</td>
<td>设置元素的上、下、左、右填充</td>
</tr>
<tr>
<td>border（边框）</td>
<td>border</td>
<td>设置四个边框的属性</td>
</tr>
<tr>
<td>border（边框）</td>
<td>borderTop<br>borderBottom<br>borderLeft<br>borderLeft<br>borderRight</td>
<td>设置上、下、左、右边框的属性</td>
</tr>
</tbody></table>
<p><strong>事件</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>当用户单击某个对象时调用事件</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标移到某元素之上</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标从某元素移开</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按钮被按下</td>
</tr>
</tbody></table>
</li>
<li><h3 id="className属性"><a href="#className属性" class="headerlink" title="className属性"></a>className属性</h3><p>在HTML DOM中，className属性可以设置或返回元素的class样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTML元素.className=<span class="string">&quot;样式名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">over</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">&quot;cart&quot;</span>).className=<span class="string">&quot;cartOver&quot;</span>;</span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">&quot;cartList&quot;</span>).className=<span class="string">&quot;cartListOver&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">&quot;cart&quot;</span>).className=<span class="string">&quot;cartOut&quot;</span>;</span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">&quot;cartList&quot;</span>).className=<span class="string">&quot;cartListOut&quot;</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​        </p>
<ol start="5">
<li><h2 id="获取元素的样式"><a href="#获取元素的样式" class="headerlink" title="获取元素的样式"></a>获取元素的样式</h2><ol>
<li><p>在JavaScript中可以使用style属性获取样式的属性值，语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTML元素.style.样式属性;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line">alert(<span class="built_in">document</span>.getElementById(<span class="string">&quot;cartList&quot;</span>).display);</span><br></pre></td></tr></table></figure></li>
<li><p>使用上面的只能获取内联样式的属性值，无法获取内部样式表或外部样式表的属性值。所以说不用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTML元素. currentStyle.样式属性;	currentStyle是只读的</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例 兼容IE</span></span><br><span class="line">alert(<span class="built_in">document</span>.getElementById(<span class="string">&quot;cartList&quot;</span>).currentStyle.display);</span><br></pre></td></tr></table></figure>

<p><strong>非IE的！！！！！！！！！！！！！！！！！！！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.defaultView.getComputedStyle(元素,<span class="literal">null</span>).属性;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">var</span> cartList=<span class="built_in">document</span>.getElementById(<span class="string">&quot;cartList&quot;</span>);</span><br><span class="line">alert(<span class="built_in">document</span>.defaultView.getComputedStyle(cartList,<span class="literal">null</span>).display);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h1 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h1><ol>
<li><p>使用currentStyle或getComputerStyle（）可以获得元素的属性值，即可以获取元素在页面上的位置，固定效果如何实现？</p>
</li>
<li><h2 id="元素属性一样"><a href="#元素属性一样" class="headerlink" title="元素属性一样"></a>元素属性一样</h2><p>一些属性可以获取滚动状态下的元素的一些属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>offsetLeft</td>
<td>返回当前元素左边界到它上级元素的左边界的距离，只读属性</td>
</tr>
<tr>
<td>offsetTop</td>
<td>返回当前元素上边界到它上级元素的上边界的距离，只读属性</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>返回元素的高度</td>
</tr>
<tr>
<td>offsetWidth</td>
<td>返回元素的宽度</td>
</tr>
<tr>
<td>offsetParent</td>
<td>返回元素的偏移容器，即对最近的动态定位的包含元素的引用</td>
</tr>
<tr>
<td>scrollTop</td>
<td>返回匹配元素的滚动条的垂直位置</td>
</tr>
<tr>
<td>scrollLeft</td>
<td>返回匹配元素的滚动条的水平位置</td>
</tr>
<tr>
<td>clientWidth</td>
<td>返回元素的可见宽度</td>
</tr>
<tr>
<td>clientHeight</td>
<td>返回元素的可见高度</td>
</tr>
</tbody></table>
<p>获取滚动条滚动的距离，这就需要使用scrollTop，scrollLeft这两个属性，获得数值单位是像素（PX），对于不滚动的元素，这两个元素值总是0。这两个属性获取滚动条在窗口中滚动的距离。语法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准浏览器</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">或者</span><br><span class="line"><span class="comment">//Chrome</span></span><br><span class="line"><span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"><span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sTop=<span class="built_in">document</span>.documentElement.scrollTop||<span class="built_in">document</span>.body.scrollTop;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li>
</ol>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511311.png" alt="image-20210716155346308"></p>
]]></content>
      <categories>
        <category>使用jQuery快速高效制作网页交互特效</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript对象及初始面向对象</title>
    <url>/2021/07/18/JavaScript%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%88%9D%E5%A7%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在JavaScript中，所有的事物都是对象，如字符串，数值，数组，函数，所以本章在讲解之间先回顾一下，学习过的JavaScript数据类型。</p>
<span id="more"></span>

<h1 id="回顾JavaScript数据类型"><a href="#回顾JavaScript数据类型" class="headerlink" title="回顾JavaScript数据类型"></a>回顾JavaScript数据类型</h1><p>JavaScript中提供了常用的基本数据类型，这些数据类型如下：</p>
<ul>
<li><p>number(数值类型)</p>
</li>
<li><p>string(字符串类型)</p>
</li>
<li><p>boolean(布尔类型)</p>
</li>
<li><p>null(空类型)</p>
</li>
<li><p>undefined(未定义类型)</p>
</li>
<li><p>object 一种复杂的数据类型，该类型实例化对象是一组数据和功能的集合。</p>
<p>要区分一下<strong>null</strong>、<strong>undefined</strong>和<strong>object</strong>这几个类型</p>
<ul>
<li>null表示无值，默认的空值null；使用typeof运算符判断数据类型返回时会不会返回null这个类型。</li>
</ul>
</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ol>
<li><h2 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h2><ol>
<li>对象是包含相关属性和方法的集合体</li>
<li>什么是面向对象<ol>
<li>面向对象仅仅是一个概念或者编程思想</li>
<li>通过一种叫做原型的方式来实现面向对象编程</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><ol>
<li><h3 id="在JavaScript中，对象分为两种"><a href="#在JavaScript中，对象分为两种" class="headerlink" title="在JavaScript中，对象分为两种"></a>在JavaScript中，对象分为两种</h3><ol>
<li><h4 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h4><ol>
<li><p>与java中创建对象一样，创建自定义对象的最简单的方式就是使用当前操作符new创建一个object的实例，然后用过 “ . ” 为其添加属性和方法，创建对象的语法如下所示。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称=<span class="keyword">new</span> <span class="built_in">Object</span>( );</span><br><span class="line">通过  . 添加属性和方法</span><br></pre></td></tr></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flower=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    flower.name=<span class="string">&quot;长春花&quot;</span>;</span><br><span class="line">    flower.genera=<span class="string">&quot;夹竹桃科 长春花属&quot;</span>;</span><br><span class="line">    flower.area=<span class="string">&quot;非洲、亚热带、热带以及中国大陆的华东、西南、中南等地&quot;</span>;</span><br><span class="line">    flower.uses=<span class="string">&quot;观赏或用药等&quot;</span>;</span><br><span class="line">    flower.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    alert(<span class="built_in">this</span>.name);    &#125;</span><br><span class="line"> flower.showName();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用字面量赋值方式创建对象</strong></p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flower=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;长春花&quot;</span>,</span><br><span class="line">        <span class="attr">genera</span>:<span class="string">&quot;夹竹桃科 长春花属&quot;</span>,</span><br><span class="line">        <span class="attr">area</span>:<span class="string">&quot;非洲、亚热带、热带以及中国大陆的华东、西南、中南等地&quot;</span>,</span><br><span class="line">        <span class="attr">uses</span>:<span class="string">&quot;观赏或用药等&quot;</span>,</span><br><span class="line">        <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="built_in">this</span>.name); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> flower.showName();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><ol>
<li><strong>JavaScript的内置对象是一种特殊的数据，常见的内置对象如下所示。</strong><ul>
<li><strong>String（字符串）对象</strong></li>
<li><strong>Date（日期）对象</strong></li>
<li><strong>Array（数组）对象</strong></li>
<li><strong>Boolean（逻辑）对象</strong></li>
<li><strong>Math（算数）对象</strong></li>
<li><strong>RegExp对象</strong></li>
</ul>
</li>
<li>其中String，Date，Array，Boolean和Math对象，我们在前面的章节已经学习过，下面简单的回顾一下。<ol>
<li>字符串是JavaScript中的一种基本的数据类型，String对象的length属性声明了该字符串中的字符数，String类定义了大量的操作字符串的方法，一般分为查找子字符串，截取和拼接字符串，匹配正则表达式，改变字符串样式等，如已学习的indexOf（）方法，replace（）方法。</li>
<li>Date对象是用于处理日期和时间，Date对象会自动吧当前日期和时间保存与其初始值，Date对象的大部分方法由如下鸡肋组成。<ol>
<li>get x x x：获取年，月，日，时，分，秒，等。</li>
<li>set x x x：设置年，月，日，时，分，秒，等。</li>
</ol>
</li>
<li>数组对象的作用是使用单独的变量名来存储一系列的值，数组的常用来那个属性是lengt，代表了这个数组元素的个数，数组常用的方法有排序，添加和删除元素，拼接另一个数组，转成字符串，如sort（），concat（），join（）方法等。</li>
<li>Boolean对象用于将非逻辑值转换为逻辑值（true或者false），在JavaScript中布尔值是一种基本的数据类型，Boolean对象是一个将布尔值打包成布尔对象。Boolean对象主要用于提供将布尔值转换成字符串类的toString（）方法。当调用toString（）方法将布尔值转换成字符串时，JavaScript会将这个布尔值转换成一个临时的Boolean对象，然后调用这个对象的toString（）方法。</li>
<li>Math对象的作用是执行常见的算书任务。Math对象并不像Date和String那样的对象，因此没有构造函数Math（），像Math.round（）这样的函数只能是函数，不能作为某个对象的方法使用。Math对象中最常见的方法有向上（向下）取整，四舍五入取整，随机数，返回两个数字中大数或小数，如round（），max（），min（）方法等。</li>
<li>RegExp对象对我们来说比较陌生，RegExp是正则表达式的缩写，当需要检索某个文本是可以使用一种模式来描述要检索的内容，RegExp就是这种模式。简单的模式可以是一个单独的字符，复杂的模式包括更多的字符，并可用于解析，格式检查，替换等。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="构造函数和原型对象"><a href="#构造函数和原型对象" class="headerlink" title="构造函数和原型对象"></a>构造函数和原型对象</h2><ol>
<li><p>如何解决使用同一个接口不需要创建很多对象，减少产生大量的重复代码？</p>
<ol>
<li><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol>
<li>构造函数可以用来创建特殊类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，此外也可以创建自定义的构造函数，</li>
<li>所谓的构造函数，就是一个普通函数，但是内部使用了this变量，对构造函数使用new操作符，就能生成实例，并且this变量会绑定在实例对象上，从而定义自定义对象类型的属性和方法。</li>
<li>构造函数始终都应该以一个大写字母开头</li>
<li>使用构造函数创建新实例，必须使用new操作符，以这种方式调用构造函数实际上会经历以下四个步骤。<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（this就执行了这个新对象）。</li>
<li>执行构造函数中的代码。</li>
<li>返回新对象</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><ol>
<li><p>每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。而这个对象的用途包含可以由特定类型的所有实例共享的属性和方法。</p>
</li>
<li><p>prototype就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处就是可以让所有对象实例共享它所有的属性和方法，也就是说不必再构造函数中定义对象实例的信息，可以将这些信息直接添加到原型对象中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Flower</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Flower.prototype.name=<span class="string">&quot;曼陀罗花&quot;</span>;</span><br><span class="line">    Flower.prototype.genera=<span class="string">&quot;茄科 曼陀罗属&quot;</span>;</span><br><span class="line">    Flower.prototype.area=<span class="string">&quot;印度、中国北部&quot;</span>;</span><br><span class="line">    Flower.prototype.uses=<span class="string">&quot;观赏或药用&quot;</span>;</span><br><span class="line">    Flower.prototype.showName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> flower1=<span class="keyword">new</span> Flower();</span><br><span class="line">    flower1.showName();</span><br><span class="line">    <span class="keyword">var</span> flower2=<span class="keyword">new</span> Flower();</span><br><span class="line">    flower2.showName();</span><br><span class="line">    alert(flower1.showName==flower2.showName);</span><br></pre></td></tr></table></figure>

<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511835.png" alt="image-20210718111954605"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象._ _proto_ _指向原型对象</span><br><span class="line">原型对象用<span class="title">constructor</span>属性指向构造函数</span><br><span class="line">类用<span class="title">prototype</span>执行原型对象</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><ol>
<li>constructor属性指向Flower<ol>
<li>原型对象用constructor属性指向构造函数</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(flower1.constructor==Flower);</span><br><span class="line">alert(flower2.constructor==Flower);</span><br><span class="line">alert(flower3.constructor==Flower);</span><br></pre></td></tr></table></figure></li>
<li><h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h2><ol>
<li><p>使用instanceof操作符检测对象类型、</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(flower1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(flower1 <span class="keyword">instanceof</span> Flower);</span><br><span class="line">alert(flower2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(flower2 <span class="keyword">instanceof</span> Flower);</span><br><span class="line">alert(flower3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(flower3 <span class="keyword">instanceof</span> Flower);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li><p>在JavaScript中，每个构造函数都拥有一个原型对象，原型对象都包含一个指向构造函数的纸张，实例都包含一个执行构造对象的内部指针。</p>
</li>
<li><p>一个原型对象是另一个原型对象的实例<br>相关的原型对象层层递进，就构成了实例与原型的链条，就是原型链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Humans</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.foot=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Humans.prototype.getFoot=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.foot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.head=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Man.prototype=<span class="keyword">new</span> Humans();          <span class="comment">//继承了Humans</span></span><br><span class="line">    Man.prototype.getHead=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> man1=<span class="keyword">new</span> Man();</span><br><span class="line">    alert(man1.getFoot());                          <span class="comment">//2</span></span><br><span class="line">    alert(man1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">//true     </span></span><br><span class="line">    alert(man1 <span class="keyword">instanceof</span> Humans);        <span class="comment">//true</span></span><br><span class="line">    alert(man1 <span class="keyword">instanceof</span> Man);          <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造函数和原型之间的关系</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511738.png" alt="image-20210718112801650"></p>
</li>
<li><p>实际上就是重写圆形对象，赋值于一个新类型的实例，也就是说，原来存于新实例中的所有属性和方法，现在也存在与新的原型对象中了</p>
</li>
<li><p>在上面的代码中，没有使用 Man默认提供的原型，而是给它换了一个新原型，这个新原型就Humans的实例。于是、新原型不仅具有作为一个Humans 的实例所拥有的全部属性和方法，而且内部还有一个指针,指向了Humans的原型。</p>
<ol>
<li>最终，man1指向了Man的原型，Man的原型又指向Humans的型。getFoot( )方法仍然还Humans.prototype 中，但是foot则位于Man. prototype 中,这是因为foot是一个实例属性,而getFootl则是一个原型方法，既然Man.prototype现在是 Humans 的实例,那么 foot当然就位于该实例中了</li>
<li>通过实现原型链，本质上实现了前面讲解的原型搜索机制,大家应该还记得,当访问一个实属性时，首先会在实例中搜索该属性．如果没有找到该属性．则会继续搜索实例的原型。在通过原型链实现继承的情况下,搜索过程就是沿着原型链继续向上,以示例6为例.调用man1 . getFoot会经历如下三个步骤。<ol>
<li>搜索实例</li>
<li>搜索Man.prototype</li>
<li>搜索Humans.prototype</li>
</ol>
</li>
<li>最后一步才会找到该方法，在找不到属性或方法的情况下，搜索过程总要一环一环地前行到原型链的末端才会停下来。</li>
<li>上面示例展示的原型链还少一环,大家知道，所有的引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数都默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向Object.prototype，这也正是所有自定义类型都会继承toString( ). valueOf()等默认方法的根本原因，所以上面示例展示的原型链中还应该包括另外一个继承层次,此示例的完整原型链如图4.8所示。</li>
<li><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511152.png" alt="image-20210718113518713"></li>
</ol>
</li>
</ol>
</li>
<li><h2 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h2><ol>
<li><p>原型链虽然很强大，可以用它米实现继承，但是也存在两个问题。最重要的是来自包含引用类型值的原型，由于包含引用类型值的原型属性会被所有实例共享，在通过原型来实现继承时，原型实际上会变成另一个类型的实例，因此，原先的实例属性也就变成了现在的原型属性了.</p>
</li>
<li><p>创建子类型的实例时，不能向父类型的构造函数中传递参数</p>
</li>
<li><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><ol>
<li><p>借用构造函数这种技术的基本思想很简单，就是在子类型构造函数的内部调用父类型构造函数,在子类型构造函数的内部通过 apply()或call()方法调用父类型的构造函数，也可以在将来新创建的对象上执行构造函数,下面先看一下 apply()和call()的语法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apply([thisOjb[,argArray]])</span><br></pre></td></tr></table></figure>

<p>应用某一对象的一个方法，用另一个对象替换当前对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">call([thisObj[,arg1[,arg2[,  [,argN]]]]])</span><br></pre></td></tr></table></figure>

<p>调用一个对象的一个方法，以另一个对象替换当前对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Humans</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Humans.call(<span class="built_in">this</span>,<span class="string">&quot;mary&quot;</span>);   <span class="comment">//继承了Humans,同时还传递了参数</span></span><br><span class="line">        <span class="built_in">this</span>.age=<span class="number">38</span>;              <span class="comment">//实例属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> man1=<span class="keyword">new</span> Man();</span><br><span class="line">    alert(man1.name);       <span class="comment">//输出mary</span></span><br><span class="line">    alert(man1.age);        <span class="comment">//输出38</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ol>
<li><p>组合继承：有时也叫做伪经典继承</p>
<ol>
<li>将原型链和借用构造函数的技术组合到一块，发挥二者之长的一种继承模式</li>
<li>使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</li>
</ol>
</li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Humans</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.clothing=[<span class="string">&quot;trousers&quot;</span>,<span class="string">&quot;dress&quot;</span>,<span class="string">&quot;jacket&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Humans.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        Humans.call(<span class="built_in">this</span>,name);    <span class="comment">//继承属性</span></span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    Man.prototype=<span class="keyword">new</span> Humans();    <span class="comment">//继承方法</span></span><br><span class="line">    Man.prototype.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> man1=<span class="keyword">new</span> Man(<span class="string">&quot;mary&quot;</span>,<span class="number">38</span>);</span><br><span class="line">    man1.clothing.push(<span class="string">&quot;coat&quot;</span>);</span><br><span class="line">    alert(man1.clothing);     <span class="comment">//输出&quot;trousers,dress,jacket,coat&quot;</span></span><br><span class="line">    man1.sayName();            <span class="comment">//输出mary</span></span><br><span class="line">    man1.sayAge();            <span class="comment">//输出38</span></span><br><span class="line">    <span class="keyword">var</span> man2=<span class="keyword">new</span> Man(<span class="string">&quot;tom&quot;</span>,<span class="number">26</span>);</span><br><span class="line">    alert(man2.clothing);    <span class="comment">//输出&quot;trousers,dress,jacket&quot;</span></span><br><span class="line">    man2.sayName();            <span class="comment">//输出tom</span></span><br><span class="line">    man2.sayAge();            <span class="comment">//输出26</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为JavaScript中最成员的继承模式，</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511300.png" alt="image-20210718114438758"></p>
]]></content>
      <categories>
        <category>使用jQuery快速高效制作网页交互特效</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis动态SQL</title>
    <url>/2021/11/24/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="MyBatis框架动态SQL处理简单的多参数查询"><a href="#MyBatis框架动态SQL处理简单的多参数查询" class="headerlink" title="MyBatis框架动态SQL处理简单的多参数查询"></a>MyBatis框架动态SQL处理简单的多参数查询</h1><h4 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h4><span id="more"></span>

<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if</td>
<td>条件判断,与Java中的if语句类似</td>
</tr>
<tr>
<td>where</td>
<td>为SQL语句动态添加where关键词</td>
</tr>
<tr>
<td>choose</td>
<td>条件条件判断,这是一个组合标签,需要与when,otherwise标签搭配使用.可实现与java中的switch与java中的switch语句类似的功能</td>
</tr>
<tr>
<td>foreach</td>
<td>以便利的方式处理集合类型参数</td>
</tr>
<tr>
<td>set</td>
<td>为sql语句动态添加set关键词,实现动态实现数据更新功能</td>
</tr>
<tr>
<td>trim</td>
<td>对sql语句进行格式化处理,添加或移除前后缀</td>
</tr>
</tbody></table>
<h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><ol>
<li>if标签是Mybatis框架动态sql技术中重要且常用的标签之一,它所实现的功能与java中的if语句基本相同,用法也很相似.</li>
<li>动态SQL技术中最常用的标签之一</li>
<li>类似于Java中的if语句</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span>  <span class="attr">test</span> = <span class="string">&quot;条件判断，返回true或false&quot;</span> &gt;</span></span><br><span class="line">	SQL语句</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h2><ol>
<li><p> 简化SQL语句中where子句处理</p>
</li>
<li><p>智能处理and、or等关键字</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;条件判断&quot;</span>&gt;</span></span><br><span class="line">		SQL语句</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	…</span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose-when、otherwise-标签"><a href="#choose-when、otherwise-标签" class="headerlink" title="choose(when、otherwise)标签"></a>choose(when、otherwise)标签</h2></li>
<li><p>是一个组合标签，通常与when、otherwise标签配合使用</p>
</li>
<li><p>类似于Java中switch语句</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;条件判断，返回true或false&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;条件判断，返回true或false&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><h3 id="迭代一个集合，通常用于in条件"><a href="#迭代一个集合，通常用于in条件" class="headerlink" title="迭代一个集合，通常用于in条件"></a>迭代一个集合，通常用于in条件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span> = <span class="string">&quot;参数名称&quot;</span>   </span></span><br><span class="line"><span class="tag">               <span class="attr">item</span> = <span class="string">&quot;元素别名&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">open</span> = <span class="string">&quot;(&quot;</span>&lt;!<span class="attr">--</span>起始位置的拼接字符<span class="attr">--</span>&gt;</span></span><br><span class="line">               separator = &quot;,&quot; <span class="comment">&lt;!--起始位置的拼接字符--&gt;</span></span><br><span class="line">               close = &quot;)&quot; <span class="comment">&lt;!--结束位置的拼接字符--&gt;</span></span><br><span class="line">               index = &quot;当前元素位置下标&quot; &gt;</span><br><span class="line">	#&#123;元素别名&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h2><ol>
<li>简化SQL语句中set子句处理</li>
<li>智能忽略更新语句尾部多出来的逗号</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;条件判断&quot;</span>&gt;</span></span><br><span class="line">		SQL语句</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	…</span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h2><ol>
<li>动态地为SQL语句添加前后缀</li>
<li>智能忽略标签前后多余的and、or或逗号等字符</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span> = <span class="string">&quot;前缀&quot;</span> </span></span><br><span class="line"><span class="tag">	  <span class="attr">suffix</span> = <span class="string">&quot;后缀&quot;</span> </span></span><br><span class="line"><span class="tag">	  <span class="attr">prefixOverrides</span> = <span class="string">&quot;忽略前缀&quot;</span> </span></span><br><span class="line"><span class="tag">	  <span class="attr">suffixOverrides</span> = <span class="string">&quot;忽略后缀&quot;</span> &gt;</span></span><br><span class="line">	…</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131512067.png" alt="image-20211124184430939"></p>
]]></content>
      <categories>
        <category>Java开发之SSM企业轻量级开发框架</category>
      </categories>
  </entry>
  <entry>
    <title>SQL映射文件详解</title>
    <url>/2021/11/19/SQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="SQL映射的XML文件"><a href="#SQL映射的XML文件" class="headerlink" title="SQL映射的XML文件"></a>SQL映射的XML文件</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>MyBatis真正的特色在于SQL映射语句，功能强大，使用简单</p>
<span id="more"></span>

<h2 id="SQL映射文件的几个顶级元素"><a href="#SQL映射文件的几个顶级元素" class="headerlink" title="SQL映射文件的几个顶级元素"></a>SQL映射文件的几个顶级元素</h2><ol>
<li><p>mapper – SQL映射文件的根元素，有一个namespace属性</p>
<ol>
<li><p>namespace属性，区别不同的mapper</p>
<ol>
<li>namespace和子元素的id联合保证唯一</li>
<li>绑定DAO接口<ol>
<li>namespace的命名必须跟某个接口同名</li>
<li>接口中的方法与映射文件中SQL语句id一一对应</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;cn.cvs.dao.sysUser.SysUserMapper&quot;&gt;</span><br><span class="line">	&lt;select id=&quot;getUserList&quot; … &gt;</span><br><span class="line">		……</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>cache – 配置给定命名空间的缓存</p>
</li>
<li><p>cache-ref – 从其他命名空间引用缓存配置</p>
</li>
<li><p><strong>resultMap</strong> – 用来描述数据库结果集和对象的对应关系</p>
</li>
<li><p>sql – 可以重用的SQL块，也可以被其他语句引用</p>
</li>
<li><p>insert – 映射插入语句</p>
</li>
<li><p>update – 映射更新语句</p>
</li>
<li><p>delete – 映射删除语句</p>
</li>
<li><p>select – 映射查询语句</p>
</li>
</ol>
<h2 id="Mybatis框架的条件查询"><a href="#Mybatis框架的条件查询" class="headerlink" title="Mybatis框架的条件查询"></a>Mybatis框架的条件查询</h2><h3 id="select单一条件查询"><a href="#select单一条件查询" class="headerlink" title="select单一条件查询"></a>select单一条件查询</h3><p>select是MyBatis中最常用的元素之一</p>
<p>select元素有很多属性，可以详细配置每一条查询语句</p>
<ol>
<li>id<ol>
<li>命名空间中唯一的标识符</li>
<li>接口中的方法与映射文件中的SQL语句id一一对应</li>
</ol>
</li>
<li>parameterType<ol>
<li>传入SQL语句的参数类型</li>
</ol>
</li>
<li>resultType<ol>
<li>SQL语句返回值类型的完整类名或别名</li>
</ol>
</li>
</ol>
<p>Mybatis框架内建的部分别名与java数据类型的映射关系</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射类型</th>
<th>别名</th>
<th>映射类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>bigdcimal或decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>int或integer</td>
<td>Integer</td>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
</tbody></table>
<h3 id="select多条件查询"><a href="#select多条件查询" class="headerlink" title="select多条件查询"></a>select多条件查询</h3><h4 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h4><ol>
<li>使用复杂数据类型<ol>
<li>Java实体类</li>
<li>Map</li>
<li>通过 #{属性名} 或者 #{map的keyName} 获取传入的值</li>
</ol>
</li>
<li>使用多个简单数据类型<ol>
<li>int、String、Date等，一个参数传递单一数值</li>
<li>使用@Param注解为参数命名，通过 #{参数名} 获取传入的值</li>
</ol>
</li>
</ol>
<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>resultMap描述如何将结果集映射到Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;userWithRoleName&quot; type=&quot;sysuser&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">&lt;result property=&quot;userRoleName&quot; column=&quot;roleName&quot;/&gt;&lt;!--从数据库中查询 的列名或者别名--&gt;</span><br><span class="line">&lt;/resultMap&gt;&lt;!--表示查询出来的字段的值 赋给实体对象的哪个属性--&gt;</span><br><span class="line">&lt;select id=&quot;getUserListWithRoleName&quot;</span><br><span class="line">&lt;resultMap=&quot;userWithRoleName&quot; parameterType=&quot;sysuser&quot;&gt;</span><br><span class="line">					&lt;!-- 一个外部resultMap的id，表示根据哪一个resultMap 映射查询结果--&gt;</span><br><span class="line">    select u.*, r.roleName from t_sys_user u, t_sys_role r</span><br><span class="line">    where u.realName like CONCAT (&#x27;%&#x27;, #&#123;realName&#125;, &#x27;%&#x27;)</span><br><span class="line">    and u.roleId = #&#123;roleId&#125; and u.roleId = r.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>resultMap元素的属性<ol>
<li>id：resultMap的唯一标识</li>
<li>type：映射的结果类型</li>
</ol>
</li>
<li>resultMap元素的子元素<ol>
<li>id：指定和数据表主键字段对应的标识属性<ol>
<li>设置此项可提高MyBatis性能</li>
</ol>
</li>
<li>result：指定结果集字段和实体类属性的映射关系</li>
<li>association：映射“多对一”或“一对一”关系</li>
<li>collection：映射“一对多”关系</li>
</ol>
</li>
</ol>
<h2 id="嵌套结果映射"><a href="#嵌套结果映射" class="headerlink" title="嵌套结果映射"></a>嵌套结果映射</h2><h3 id="association"><a href="#association" class="headerlink" title="association"></a>association</h3><ul>
<li><p>复杂的关联类型，映射一个嵌套JavaBean属性</p>
</li>
<li><p>多对一或一对一</p>
</li>
<li><p>属性</p>
<ul>
<li>property：用来映射查询结果子集的实体属性</li>
<li>javaType：完整Java类名或者别名</li>
<li>resultMap：引用外部resultMap</li>
</ul>
</li>
<li><p>子元素</p>
<ul>
<li><p>id</p>
</li>
<li><p>result</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;!-- &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">       &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">       &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;</span><br><span class="line">       &lt;result property=&quot;dept_id&quot; column=&quot;dept_id&quot;&gt;&lt;/result&gt;--&gt;</span><br><span class="line">    </span><br><span class="line">       &lt;!--对象属性--&gt;</span><br><span class="line">       &lt;association property=&quot;dept&quot; javaType=&quot;com.s3.pojo.Dept&quot;&gt;</span><br><span class="line">           &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">           &lt;!--&lt;result property=&quot;dept_name&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;--&gt;</span><br><span class="line">       &lt;/association&gt;</span><br><span class="line">   &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul>
<li><p>复杂类型集合，映射嵌套结果集到一个列表</p>
</li>
<li><p><strong>一对多</strong></p>
</li>
<li><p>属性</p>
<ul>
<li>property：实体类中用来映射查询结果子集的集合属性</li>
<li>ofType：集合中元素的类型，完整Java类名或者别名</li>
<li>resultMap：引用外部resultMap</li>
</ul>
</li>
<li><p>子元素</p>
<ul>
<li>id</li>
<li>result</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><ul>
<li>直接表示返回类型</li>
<li>适用于比较简单直接的数据封装场景</li>
</ul>
<h4 id="resultMap-1"><a href="#resultMap-1" class="headerlink" title="resultMap"></a>resultMap</h4><ul>
<li>是对外部resultMap的引用</li>
<li>能够处理结果集字段名与实体类属性名不一致、或者需要对连接查询结果使用嵌套映射等较为复杂的问题</li>
</ul>
<p><strong>二者本质上都是基于Map数据结构，不能同时使用</strong></p>
<h3 id="MyBatis自动映射"><a href="#MyBatis自动映射" class="headerlink" title="MyBatis自动映射"></a>MyBatis自动映射</h3><ul>
<li><p>自动映射的前提：属性名与字段名一致</p>
</li>
<li><p>自动映射级别：autoMappingBehavior</p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting  name=&quot;autoMappingBehavior&quot; </span><br><span class="line">			   value=&quot;[ NONE | PARTIAL | FULL ]&quot; /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>自动映射行为</th>
<th>resultType  （不支持嵌套映射）</th>
<th>没有嵌套映射的resultMap</th>
<th>有嵌套映射的resultMap</th>
</tr>
</thead>
<tbody><tr>
<td>NONE</td>
<td>失效</td>
<td>手工映射</td>
<td>手工映射</td>
</tr>
<tr>
<td>PARTIAL</td>
<td>自动映射</td>
<td>自动映射</td>
<td>手工映射</td>
</tr>
<tr>
<td>FULL</td>
<td>自动映射</td>
<td>自动映射</td>
<td>自动映射</td>
</tr>
</tbody></table>
<h2 id="Mybatis框架的增删改查操作"><a href="#Mybatis框架的增删改查操作" class="headerlink" title="Mybatis框架的增删改查操作"></a>Mybatis框架的增删改查操作</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><ul>
<li><p>id</p>
</li>
<li><p>parameterType</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;add&quot; parameterType=&quot;sysuser&quot;&gt;</span><br><span class="line">    insert into t_sys_user (account, realName, password, …… )</span><br><span class="line">    values (#&#123;account&#125;, #&#123;realName&#125;, #&#123;password&#125;, …… )</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>增删改（insert、update、delete）这类操作通常返回影响行数，<br>insert、update、delete元素均没有resultType/resultMap属性</p>
</blockquote>
</li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><ul>
<li>id</li>
<li>parameterType</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;modify&quot; parameterType=&quot;sysuser&quot;&gt;</span><br><span class="line">update t_sys_user set account=#&#123;account&#125;, realName=#&#123;realName&#125;, ……</span><br><span class="line">where id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li>id</li>
<li>parameterType</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;integer&quot;&gt;</span><br><span class="line">    delete from t_sys_user where id=#&#123;id&#125;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h3 id="MyBatis传参方式选择"><a href="#MyBatis传参方式选择" class="headerlink" title="MyBatis传参方式选择"></a>MyBatis传参方式选择</h3><blockquote>
<p>参数较多时最好封装成对象入参<br>参数组合比较固定的业务方法，最好使用多参数入参，代码可读性高</p>
</blockquote>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>一级缓存</li>
<li>二级缓存</li>
</ul>
<p>二级缓存的配置</p>
<ul>
<li><p>MyBatis的全局cache配置</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在SQL映射文件中设置缓存，默认情况下是没有开启缓存的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; </span><br><span class="line">        size=&quot;512&quot; readOnly=&quot;true&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在SQL映射文件配置支持cache后，如果需要对个别查询进行调整，可以单独设置</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectAll&quot; resultType=&quot;SysUser&quot; </span><br><span class="line">        useCache=&quot;true&quot;&gt;</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  <img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131512260.png" alt="image-20211119190552285"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java开发之SSM企业轻量级开发框架</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis知识点</title>
    <url>/2021/11/15/Mybatis%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131512839.png" alt="image-20211124184824250"></p>
]]></content>
      <categories>
        <category>Java开发之SSM企业轻量级开发框架</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Windows系统使用技巧</title>
    <url>/2021/07/07/Windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>虽然用了好久的电脑，但是对很多系统的常用技巧都不熟悉，也不曾总结，这一次借看书的机会总结一下。 </p>
<span id="more"></span>

<h1 id="开启超级管理员账户Administrotor"><a href="#开启超级管理员账户Administrotor" class="headerlink" title="开启超级管理员账户Administrotor"></a><strong>开启超级管理员账户Administrotor</strong></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user administrator /active:yes</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user administrator /active:no </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>hexo语法合集</title>
    <url>/2021/06/30/hexo%E8%AF%AD%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="写在前头："><a href="#写在前头：" class="headerlink" title="写在前头："></a>写在前头：</h2><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html"><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></a></p>
<span id="more"></span>


<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><ol>
<li><p>新建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;my blog&quot;</span></span><br></pre></td></tr></table></figure>

<p>新建的文件在 hexo/source/_posts/my-blog.md</p>
</li>
<li><p>生成静态页面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>一般部署上去的时候都需要编译一下，编译后，会出现一个 public 文件夹，将所有的md文件编译成html文件</p>
</li>
<li><p>开启本地服务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li><p>部署</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>部署到git上的时候，需要用这个命令，下一篇中，我们会使用到这个命令</p>
</li>
<li><p>清除 public</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>当 source 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。</p>
</li>
</ol>
<h2 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h2><!--more-->


<h2 id="新建分类"><a href="#新建分类" class="headerlink" title="新建分类"></a>新建分类</h2><p>修改主题的配置文件themes/next/_config.yml，生效分类和标签：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">home</span>: <span class="string">/ || home</span></span><br><span class="line"><span class="comment">  #about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags</span>: <span class="string">/tags/ || tags</span></span><br><span class="line">  <span class="attr">categories</span>: <span class="string">/categories/ || th</span></span><br><span class="line">  <span class="attr">archives</span>: <span class="string">/archives/ || archive</span></span><br><span class="line"><span class="comment">  #schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="comment">  # sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="comment">  #commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>新创建的hexo博客没有分类和标签，点击分类或标签会提示”Cannot GET /categories/“和”Cannot GET /tags/”。</p>
<ol>
<li><p>分类：</p>
<p>进入hexo博客所在的根目录，输入如下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page categories</span><br></pre></td></tr></table></figure>

<p>成功后提示：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INFO  Created: HEXO_ROOT\source\categories\index.md</span><br></pre></td></tr></table></figure>

<p>index.md的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: <span class="number">2019</span><span class="number">-07</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">10</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这个index.md可以认为是存放分类的一个文档，只是type不同。修改为如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2019</span><span class="number">-07</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">10</span></span><br><span class="line">type: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>找到source/_posts路径下的markdown文章，并修改其categories属性。以hexo自带的hexo-world.md为例，文件头修改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2019</span><span class="number">-06</span><span class="number">-28</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">00</span></span><br><span class="line">categories: hexo</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时，点击菜单栏中的“分类”，即可看到新建的“hexo”分类。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签创建与分类类似，在控制台中输入如下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page tags</span><br><span class="line">INFO  Created: HEXO_ROOT\source\tags\index.md</span><br></pre></td></tr></table></figure>

<p>tags/index.md内容与分类类似，修改为如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2019</span><span class="number">-07</span><span class="number">-14</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">31</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同样在hello-world.md增加标签内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2019</span><span class="number">-06</span><span class="number">-28</span> <span class="number">22</span>:<span class="number">36</span>:<span class="number">00</span></span><br><span class="line">categories: hexo</span><br><span class="line">tags:</span><br><span class="line">  - hexo</span><br><span class="line">  - others</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-NexT主题添加点击爱心效果"><a href="#Hexo-NexT主题添加点击爱心效果" class="headerlink" title="Hexo NexT主题添加点击爱心效果"></a>Hexo NexT主题添加点击爱心效果</h2><ol>
<li><p>创建js文件</p>
<p>在<code>/themes/next/source/js/src</code>下新建文件<code>clicklove.js</code>，接着把该代码拷贝粘贴到<code>clicklove.js</code>文件中。<br>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>修改_layout.swig</p>
</li>
</ol>
<p>在<code>\themes\next\layout\_layout.swig</code>文件末尾添加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>关于S3考试 Mysql建库建表SQL语句 的讲解</title>
    <url>/2022/05/13/%E5%85%B3%E4%BA%8ES3%E8%80%83%E8%AF%95-Mysql%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8SQL%E8%AF%AD%E5%8F%A5-%E7%9A%84%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>老样子,应付S3考试出的一个公式 –==赵牛逼专属==</p>
<span id="more"></span>

<h1 id="建库语句"><a href="#建库语句" class="headerlink" title="建库语句"></a>建库语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 库名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面两个单词是固定的</p>
<p>S3结业考试题没有固定库名 随便写就行</p>
</blockquote>
<h1 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span>建列</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面两个单词是固定的</p>
<p>表名就是题目上面给的</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>基本上两个表的sql语句都是下面这种</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131610432.png" alt="image-20220513160910674"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 表名;</span><br><span class="line">use 表名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trip_mode(</span><br><span class="line"> 	id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"> 	NAME <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> schedule(</span><br><span class="line">    id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    user_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    duty <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    trip_mode_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    STATUS <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    depart_time <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h1 id="对于建表里面的语句"><a href="#对于建表里面的语句" class="headerlink" title="对于建表里面的语句"></a>对于建表里面的语句</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">列名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">列名 数据类型 AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY</span><br></pre></td></tr></table></figure>

<p>​        1. 第一个是除了主键的写法  </p>
<blockquote>
<p>如果写非空的那一栏不写 或者是可空==not null==就可以不写</p>
</blockquote>
<p>​        2. 第二个是主键 并且自动增长的写法</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>直接来张表 基本上涉及到考试能用到的 对着写就行了</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>单词</th>
</tr>
</thead>
<tbody><tr>
<td>长整型</td>
<td>bigint</td>
</tr>
<tr>
<td>整形</td>
<td>int</td>
</tr>
<tr>
<td>字符串</td>
<td>varchar(50)</td>
</tr>
<tr>
<td>日期类型</td>
<td>date</td>
</tr>
</tbody></table>
<h2 id="其他应该注意的"><a href="#其他应该注意的" class="headerlink" title="其他应该注意的"></a>其他应该注意的</h2><p>每一行后面最好加 <code>;</code></p>
<p>在建表里面的 列什么的 每写完一个列就需要加 <code>,</code>   最后一个不需要加 这个必须加</p>
<h1 id="主键外键怎么建"><a href="#主键外键怎么建" class="headerlink" title="主键外键怎么建"></a>主键外键怎么建</h1><p>建完表之后 刷新显示两个表 在列多的表名上面右键</p>
<p>选择 ==关联/外键==</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131622739.png" alt="image-20220513162223656"></p>
<p>点击创建之后</p>
<p>在弹出的窗口上面 ==引用表== 选择另一个表</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131625910.png" alt="image-20220513162457383"></p>
<p>在左边的窗口选择备注带 主键或者外键的列 通常是列名中有id的</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131625278.png" alt="image-20220513162550822"></p>
<p>然后点击创建 就创建好了</p>
<h1 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h1><p>先新增列少的那张表</p>
<p>在新增列多的那张表</p>
<blockquote>
<p>不然会报错</p>
</blockquote>
<p>==强烈建议 新增三条数据==</p>
<h1 id="两表查询"><a href="#两表查询" class="headerlink" title="两表查询"></a>两表查询</h1><p>怎么写</p>
<p>打个例子举个锤子</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131633204.png" alt="image-20220513163320881"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> card_type.name,gym_card.<span class="operator">*</span></span><br><span class="line">       <span class="keyword">from</span> card_type <span class="keyword">inner</span> <span class="keyword">JOIN</span> gym_card <span class="keyword">on</span> card_type.id <span class="operator">=</span> gym_card.card_type_id</span><br><span class="line">   <span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line">       <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;card_type_id!=null and card_type_id!= &#x27;&#x27; and card_type_id!= -1&quot;<span class="operator">&gt;</span></span><br><span class="line">           card_type_id<span class="operator">=</span>#&#123;card_type_id&#125;</span><br><span class="line">       <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">   <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">where</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> open_date <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><blockquote>
<p>select ==列少的表== . ==除了主键的那个列==  ,     ==另一个表==  .*</p>
</blockquote>
<h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><blockquote>
<p>from ==列少的表==   .   ==主键== inner join ==列多的表== on ==列少的表==  .  ==主键== =  ==列多的表==  .   ==外键==</p>
</blockquote>
<blockquote>
<p>外键 :==通常是备注里面说对应什么什么的主键 或者是带有外键字样的 就是上面建立主外键 去选择的那个列== </p>
</blockquote>
<h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><blockquote>
<where> 
</where></blockquote>
<p>肯定有条件</p>
<h3 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h3><blockquote>
<p> &lt;if test=&quot; ==外键== !=null and ==外键==  != ‘’ and ==外键==  != -1&quot;&gt;</p>
</blockquote>
<p>上面的 使用带下拉框</p>
<blockquote>
<p> &lt;if test=&quot; ==外键== !=null and ==外键==  != ‘’&gt;</p>
</blockquote>
<p>不带下拉框的</p>
<p>带下拉框的有一个 ==外键==  != -1 的判断</p>
<h3 id="第五行"><a href="#第五行" class="headerlink" title="第五行"></a>第五行</h3><p>也是分为两种情况</p>
<p>带下拉框的</p>
<blockquote>
<p> ==外键==  =  #{==外键==}</p>
</blockquote>
<p>不带下拉框的</p>
<blockquote>
<p> ==外键==  like concat(‘%’,#{ ==外键== }, ‘%’)</p>
</blockquote>
<h3 id="第八行"><a href="#第八行" class="headerlink" title="第八行"></a>第八行</h3><blockquote>
<p>order by ==时间列== desc</p>
</blockquote>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131655965.png" alt="image-20220513165449256"></p>
<p>就是这个列</p>
<h1 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h1> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update 表名</span><br><span class="line"><span class="keyword">set</span> status <span class="operator">=</span> <span class="number">1</span><span class="operator">-</span>status</span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;;</span><br></pre></td></tr></table></figure>

<p>适用于来回切换 只需要传id 就行 </p>
<p>如果原来的值是1 那么计算完之后就是0</p>
<p>如果 值是1 那么 1-这个值就是 0  1-1=0</p>
<p>如果值是0 那么 1-这个值就是 1   1-0=1</p>
]]></content>
      <tags>
        <tag>S3考试</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2999/01/01/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<h1 id="这只是一个静态博客"><a href="#这只是一个静态博客" class="headerlink" title="这只是一个静态博客"></a>这只是一个静态博客</h1><ol>
<li>WordPress博客将会在2022年6月1日正式上线</li>
<li>本博客是2021年创建的</li>
<li>博客是Hexo 主题是Next 托管与 <a href="https://gitee.com/">Gitee</a></li>
<li>我的Gitee地址 <a href="https://gitee.com/olinl">https://gitee.com/olinl</a></li>
</ol>
]]></content>
      <tags>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Hexo</title>
    <url>/2021/07/09/%E5%AE%89%E8%A3%85Hexo/</url>
    <content><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><ol>
<li><p>先安装git和node</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131508268.png" alt="image-20210709203602142"></p>
</li>
<li><p>安装hexo</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli	<span class="comment">//下载安装Hexo</span></span><br><span class="line">hexo init Hexo <span class="comment">//安装到当前目录的hexo文件夹内</span></span><br><span class="line">cd Hexo	<span class="comment">//切换到站点目录</span></span><br><span class="line">npm install	<span class="comment">//安装hexo到当前文件夹</span></span><br><span class="line">hexo clean	<span class="comment">//清除缓存</span></span><br><span class="line">hexo g	<span class="comment">//重新生成代码</span></span><br><span class="line">heox s	<span class="comment">//部署到本地 	开启hexo服务,到localhost:4000可以查看网页</span></span><br></pre></td></tr></table></figure>

<p>输入玩hexo s 之后服务会启动,在浏览器输入localhost:4000就可以访问  <strong>Ctrl+C</strong>来停止服务</p>
</li>
<li><p>安装完成之后,制定文件夹目录下有:</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li><strong>_config.yml: 博客的配置文件</strong></li>
</ul>
</li>
<li><p>hexo的基本配置</p>
<ol>
<li><p>_config.yml文件描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:<span class="comment">//hexo.io/docs/configuration.html</span></span><br><span class="line">## Source: https:<span class="comment">//github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo	<span class="comment">//网站标题</span></span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;	//网站副标题</span></span><br><span class="line"><span class="string">description: &#x27;</span><span class="string">&#x27;	//网站描述		主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词</span></span><br><span class="line"><span class="string">keywords:</span></span><br><span class="line"><span class="string">author: John Doe	//您的名字		参数用于主题显示文章的作者。</span></span><br><span class="line"><span class="string">language: en		//网站使用的语言</span></span><br><span class="line"><span class="string">timezone: &#x27;</span><span class="string">&#x27;		//网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># URL</span></span><br><span class="line"><span class="string">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;</span>https:<span class="comment">//username.github.io/project&#x27;</span></span><br><span class="line">url: http:<span class="comment">//example.com		//网址</span></span><br><span class="line">permalink: :year/:month/:day/:title/	<span class="comment">//文章的 永久链接 格式</span></span><br><span class="line">permalink_defaults:						<span class="comment">//永久链接中各部分的默认值</span></span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: <span class="literal">true</span> # Set to <span class="literal">false</span> to remove trailing <span class="string">&#x27;index.html&#x27;</span> from permalinks</span><br><span class="line">  trailing_html: <span class="literal">true</span> # Set to <span class="literal">false</span> to remove trailing <span class="string">&#x27;.html&#x27;</span> from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: <span class="keyword">public</span></span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of <span class="keyword">new</span> posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: <span class="literal">false</span> # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: <span class="literal">true</span> # Open external links in <span class="keyword">new</span> tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">filename_case: 0</span></span><br><span class="line"><span class="string">render_drafts: false</span></span><br><span class="line"><span class="string">post_asset_folder: false</span></span><br><span class="line"><span class="string">relative_link: false</span></span><br><span class="line"><span class="string">future: true</span></span><br><span class="line"><span class="string">highlight:</span></span><br><span class="line"><span class="string">  enable: true</span></span><br><span class="line"><span class="string">  line_number: true</span></span><br><span class="line"><span class="string">  auto_detect: false</span></span><br><span class="line"><span class="string">  tab_replace: &#x27;</span>&#x27;</span><br><span class="line">  wrap: <span class="literal">true</span></span><br><span class="line">  hljs: <span class="literal">false</span></span><br><span class="line">prismjs:</span><br><span class="line">  enable: <span class="literal">false</span></span><br><span class="line">  preprocess: <span class="literal">true</span></span><br><span class="line">  line_number: <span class="literal">true</span></span><br><span class="line">  tab_replace: <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Home page setting</span></span><br><span class="line"><span class="string"># path: Root path for your blogs index page. (default = &#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="string"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="string">index_generator:</span></span><br><span class="line"><span class="string">  path: &#x27;</span>&#x27;</span><br><span class="line">  per_page: <span class="number">10</span></span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">#<span class="meta"># https:<span class="comment">//developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span></span><br><span class="line">meta_generator: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse <span class="keyword">and</span> display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">#<span class="meta"># http:<span class="comment">//momentjs.com/docs/#/displaying/format/</span></span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## updated_option supports <span class="string">&#x27;mtime&#x27;</span>, <span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;empty&#x27;</span></span><br><span class="line">updated_option: <span class="string">&#x27;mtime&#x27;</span></span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to <span class="number">0</span> to disable pagination</span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include / Exclude file(s)</span><br><span class="line">#<span class="meta"># <span class="meta-keyword">include</span>:/exclude: options only apply to the <span class="meta-string">&#x27;source/&#x27;</span> folder</span></span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: landscape<span class="comment">//主题!!!</span></span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https:<span class="comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><ol>
<li><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: <span class="number">2013</span>/<span class="number">7</span>/<span class="number">13</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">25</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
</tr>
<tr>
<td>updated</td>
<td>开启文章的评论功能</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
</tr>
</tbody></table>
<p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h3><ol>
<li><p>当你每一次使用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> paper</span><br></pre></td></tr></table></figure>

<p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p>
<p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<p>而new这个命令其实是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>只不过这个layout默认是post罢了。</p>
</li>
<li><h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>如果你想另起一页，那么可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page board</span><br></pre></td></tr></table></figure>

<p>系统会自动给你在source文件夹下创建一个board文件夹，<a href="http://以及board文件夹中的index.md/">以及board文件夹中的index.md</a>，这样你访问的board对应的链接就是<code>http://xxx.xxx/board</code></p>
</li>
<li><h4 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h4><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> draft newpage</span><br></pre></td></tr></table></figure>

<p>这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure>

<p>在本地端口中开启服务预览。</p>
<p>如果你的草稿文件写完了，想要发表到post中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hexo publish draft newpage</span><br></pre></td></tr></table></figure>

<p>就会自动把newpage.md发送到post中。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h2><p>`.安装字数统计插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-symbols-count-time --save</span></span><br></pre></td></tr></table></figure>

<p>2.编辑<strong>主题配置文件</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>     </span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>     <span class="comment"># 文章字数</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span>    <span class="comment"># 本站所有文章字数</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>





<h2 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h2><h3 id="Local-Search"><a href="#Local-Search" class="headerlink" title="Local Search"></a>Local Search</h3><p>1.安装local search插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure>

<p>2.编辑站点配置文件，新增以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>3.编辑主题配置文件，启用local search功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<h2 id="修改文章底部标签"><a href="#修改文章底部标签" class="headerlink" title="修改文章底部标签[#]#"></a>修改文章底部标签[#]#</h2><p>1.打开编辑<code>themes\next\layout\_macro\post.swig</code></p>
<p>2.<code>Ctrl+F</code>找到<code>rel=&quot;tag&quot;&gt;#</code></p>
<p>3.将<code>#</code>替换为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="文章底部添加”本文结束”"><a href="#文章底部添加”本文结束”" class="headerlink" title="文章底部添加”本文结束”"></a>文章底部添加”本文结束”</h2><p>打开编辑<code>themes\next\layout\_macro\post.swig</code>，在文章结束的地方添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;</span></span><br><span class="line">		---------Thanks for your attention---------</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>





<p>文章添加阴影、透明效果<br>打开 theme/next/source/css/_custom/custom.styl，添加以下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line">.post &#123;</span><br><span class="line">   margin-top: <span class="number">60</span>px;</span><br><span class="line">   margin-bottom: <span class="number">60</span>px;</span><br><span class="line">   padding: <span class="number">25</span>px;</span><br><span class="line">   background:rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>) none repeat scroll !important;</span><br><span class="line">   -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>)</span></span>;</span><br><span class="line">   -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>新建文章时，在相同目录下创建同名文件夹（便于图片管理）<br>打开站点配置文件_config.yml，搜索post_asset_folder字段，设置其值为true<br>安装hexo-asset-image：npm install hexo-asset-image –save<br>此时hexo new “fileName”会在/source/_posts目录下创建同名的文件夹<br>只需在 md 文件里使用 <img src="/2021/07/09/%E5%AE%89%E8%A3%85Hexo/%E5%9B%BE%E7%89%87%E5%90%8D.jpg" alt="title"> ，无需路径名就可以插入图片。</p>
<h2 id="首页显示文章摘要（阅读全文）及配图（文章内不重复显示）"><a href="#首页显示文章摘要（阅读全文）及配图（文章内不重复显示）" class="headerlink" title="首页显示文章摘要（阅读全文）及配图（文章内不重复显示）"></a>首页显示文章摘要（阅读全文）及配图（文章内不重复显示）</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>excerpt</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">auto_excerpt: <span class="comment">//自动摘录</span></span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  length: <span class="number">150</span> <span class="comment">//摘录字数</span></span><br><span class="line">read_more_btn: <span class="literal">true</span> <span class="comment">//显示全文按钮</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开<code>themes\next\layout\_macro\post.swig</code>，在<code>&#123;% if is_index %&#125;</code>和<code>&#123;% if post.description and theme.excerpt_description %&#125;</code>之间添加如下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> post.images %&#125;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;out-img-topic&quot;</span>&gt;</span><br><span class="line">		&lt;img src=&#123;&#123; post.images &#125;&#125; class=<span class="string">&quot;img-topic&quot;</span>&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>向<code>themes\next\source\css\_custom\custom.styl</code>中添加如下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文章摘要配图</span></span><br><span class="line"><span class="comment">//图片外部的容器方框，限制图片大小</span></span><br><span class="line">.out-img-topic &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  max-height:<span class="number">500</span>px;</span><br><span class="line">  margin-bottom: <span class="number">24</span>px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图片</span></span><br><span class="line">img.img-topic &#123;</span><br><span class="line">  display: block ;</span><br><span class="line">  margin-left: <span class="number">.7</span>em;</span><br><span class="line">  margin-right: <span class="number">.7</span>em;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span>: right;</span><br><span class="line">  clear: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将摘要图片储存于<code>themes\next\source\images</code>中，建议<strong>在此路径下</strong>单独建一个文件夹存放摘要图片，<strong>这个图片和文章中插图的存放路径不同，不是一个概念</strong>。然后在文章YAML头信息中添加images字段，将值填为<code>/images/imagename.jpg</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">images: <span class="string">&quot;images/文章摘要配图/Win10桌面.png&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="博客总访问量统计"><a href="#博客总访问量统计" class="headerlink" title="博客总访问量统计"></a>博客总访问量统计</h2><p> 打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>busuanzi</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">false</span></span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: <span class="literal">false</span></span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: eye</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</p>
<ul>
<li>打开<code>/themes/next/layout/_partials/footer.swig</code>，在最后添加如下内容：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;busuanzi_container_site_uv&quot;</span>&gt;</span><br><span class="line">  本站访问次数：&lt;span class=<span class="string">&quot;busuanzi-value&quot;</span> id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="文章末尾添加版权声明"><a href="#文章末尾添加版权声明" class="headerlink" title="文章末尾添加版权声明"></a>文章末尾添加版权声明</h2><p><strong>配置：</strong><br>查找主题配置文件<code>themes/next/_config.yml</code>中的<code>creative_commons</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  post: <span class="literal">true</span>  # 将<span class="literal">false</span>改为<span class="literal">true</span>即可显示版权信息</span><br><span class="line">  language:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程类</category>
      </categories>
  </entry>
  <entry>
    <title>初始MyBatis框架</title>
    <url>/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="框架的简单介绍"><a href="#框架的简单介绍" class="headerlink" title="框架的简单介绍"></a>框架的简单介绍</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种经过检验的,具有特定功能的未成品软件</p>
<ol>
<li>是一个应用程序的半成品</li>
<li>提供可重用的公共结构</li>
<li>按一定规则组织的一组组件</li>
</ol>
<span id="more"></span>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>不用再考虑公共问题</li>
<li>专心在业务实现上</li>
<li>结构统一，易于学习、维护</li>
<li>新手也可写出好程序 </li>
</ol>
<h3 id="主流框架"><a href="#主流框架" class="headerlink" title="主流框架"></a>主流框架</h3><h4 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis<img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117184314611.png" alt="image-20211117184314611"></h4><ol>
<li>半自动化的ORM实现</li>
<li>DAO层 对数据库层打交道</li>
<li>动态SQL</li>
<li>小巧灵活、简单易学</li>
</ol>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring<img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117184436238.png" alt="image-20211117184436238"></h4><ol>
<li><p>依赖注入容器 / AOP实现</p>
</li>
<li><p>声明式事务</p>
</li>
<li><p>简化Java EE应用</p>
</li>
<li><p>黏合剂，将大家组装到一起</p>
</li>
</ol>
<h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><ol>
<li>结构最清晰的MVC Model2实现</li>
<li>高度可配置，支持多种视图技术</li>
<li>定制化开发</li>
</ol>
<h4 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts<img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117184618691.png" alt="image-20211117184618691"></h4><ol>
<li>MVC设计模式的实现</li>
<li>拦截器</li>
<li>可变和可重用的标签</li>
</ol>
<h4 id="HiberNate"><a href="#HiberNate" class="headerlink" title="HiberNate"></a>HiberNate<img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117184648598.png" alt="image-20211117184648598"></h4><ol>
<li>ORM，简化数据库操作</li>
<li>DAO层</li>
</ol>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ol>
<li>定义：持久化是程序数据在瞬时状态和持久状态间转换的过程</li>
<li>实现持久化的方式<ol>
<li>文件</li>
<li>数据库</li>
</ol>
</li>
</ol>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ol>
<li><em>ORM</em>一般指对象关系映射。 对象关系映射（英语：Object Relational Mapping，简称<em>ORM</em>，或O/RM，或O/R mapping）<ol>
<li>​      O Object 对象  R Relational 关系 M Mapping 映射</li>
<li>​    编写程序的时候，以面向对象的方式处理数据</li>
<li>保存数据的时候，却以关系型数据库的方式存储</li>
</ol>
</li>
<li>ORM解决方案包含下面四个部分<ol>
<li>在持久化对象上执行基本的增、删、改、查操作</li>
<li>对持久化对象提供一种查询语言或者API</li>
<li>对象关系映射工具</li>
<li>提供与事务对象交互、执行检查、延迟加载以及其他优化功能</li>
</ol>
</li>
</ol>
<h3 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h3><ol>
<li>MyBatis前身是iBatis，本是Apache的一个开源的项目</li>
<li>官方网站:<a href="http://mybatis.org/">http://mybatis.org</a></li>
<li>ORM框架</li>
<li>特点<ol>
<li>实体类和SQL语句之间建立映射关系</li>
<li>基于SQL语法，简单易学</li>
<li>SQL语句封装在配置文件中，便于统一管理与维护，降低程序的耦合度</li>
</ol>
</li>
</ol>
<h1 id="上机实操"><a href="#上机实操" class="headerlink" title="上机实操"></a>上机实操</h1><h2 id="搭建MyBatis开发环境"><a href="#搭建MyBatis开发环境" class="headerlink" title="搭建MyBatis开发环境"></a>搭建MyBatis开发环境</h2><ol>
<li>下载mybatis-3.5.1.jar</li>
<li>将所需jar文件导入工程</li>
<li>编写MyBatis核心配置文件 <strong>类似于BaseDao  用于连接的信息</strong></li>
<li>创建实体类（POJO）</li>
<li>定义DAO层Mapper接口</li>
<li>定义SQL映射文件  <strong>类似于sql java代码</strong></li>
<li>创建测试类<ol>
<li>读取MyBatis核心配置文件</li>
<li>创建SqlSessionFactory实例</li>
<li>创建SqlSession实例</li>
<li>创建Mapper实例执行SQL映射文件中的SQL语句</li>
</ol>
</li>
</ol>
<blockquote>
<h1 id="Mybatis基本使用-X"><a href="#Mybatis基本使用-X" class="headerlink" title="Mybatis基本使用(X)"></a>Mybatis基本使用(<u>X</u>)</h1><ol>
<li>创建web项目，加jar包</li>
<li>编写mybatis核心配置文件mybatis_config.xml</li>
<li>编写实体类(pojo)</li>
<li>编写接口</li>
<li>编写sql映射文件</li>
<li>创建业务类<ol>
<li>读取MyBatis核心配置文件</li>
<li>创建SqlSessionFactory实例</li>
<li>创建SqlSession实例</li>
<li>创建Mapper实例执行SQL映射文件中的SQL语句</li>
</ol>
</li>
<li>创建启动类并运行</li>
</ol>
</blockquote>
<h1 id="小点"><a href="#小点" class="headerlink" title="小点"></a>小点</h1><h2 id="以实体类封装查询结果"><a href="#以实体类封装查询结果" class="headerlink" title="以实体类封装查询结果"></a>以实体类封装查询结果</h2><h3 id="Mapper接口中添加查询用户列表的方法声明"><a href="#Mapper接口中添加查询用户列表的方法声明" class="headerlink" title="Mapper接口中添加查询用户列表的方法声明"></a>Mapper接口中添加查询用户列表的方法声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;SysUser&gt;  <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="SQL映射文件中添加查询用户列表的select节点"><a href="#SQL映射文件中添加查询用户列表的select节点" class="headerlink" title="SQL映射文件中添加查询用户列表的select节点"></a>SQL映射文件中添加查询用户列表的select节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;select  id=&quot;getUserList&quot;  resultType=&quot;cn.cvs.pojo.SysUser&quot;&gt; </span><br><span class="line">&lt;!-- id是方法名 resultType 是返回值的类型 --&gt;</span><br><span class="line">      select * from t_sys_user</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="与JDBC直观对比"><a href="#与JDBC直观对比" class="headerlink" title="与JDBC直观对比"></a>与JDBC直观对比</h2><h3 id="MyBatis将代码分解包装"><a href="#MyBatis将代码分解包装" class="headerlink" title="MyBatis将代码分解包装!!!"></a>MyBatis将代码分解包装!!!</h3><h2 id="MyBatis框架优缺点"><a href="#MyBatis框架优缺点" class="headerlink" title="MyBatis框架优缺点"></a>MyBatis框架优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>与JDBC相比，减少了50%以上的代码量</li>
<li>最简单的持久化框架，小巧并简单易学</li>
<li>SQL代码从程序代码中彻底分离，可重用</li>
<li>提供XML标签，支持编写动态SQL</li>
<li>提供映射标签，支持对象与数据库的ORM字段映射</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>SQL语句编写工作量大，对开发人员有一定要求</li>
<li>数据库移植性差</li>
</ol>
<p><strong>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案，适用于性能要求较高或者需求多变的互联网项目</strong></p>
<h2 id="MyBatis基本要素"><a href="#MyBatis基本要素" class="headerlink" title="MyBatis基本要素"></a>MyBatis基本要素</h2><ol>
<li>MyBatis的核心对象<ol>
<li>SqlSessionFactoryBuilder</li>
<li>SqlSessionFactory</li>
<li>SqlSession</li>
</ol>
</li>
<li>MyBatis核心配置文件</li>
<li>SQL映射文件</li>
</ol>
<h2 id="核心接口和类的关系"><a href="#核心接口和类的关系" class="headerlink" title="核心接口和类的关系"></a>核心接口和类的关系</h2><p><img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117190825435.png" alt="image-20211117190825435"></p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a><strong>SqlSessionFactoryBuilder</strong></h3><p>用过即丢，其生命周期只存在于方法体内<br>负责构建SqlSessionFactory，并提供多个build()方法的重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取XML文件构造方式</span></span><br><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>; 　　</span><br><span class="line">InputStream is = Resources.getResourceAsStream(resource); 　　</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br></pre></td></tr></table></figure>

<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a><strong>SqlSessionFactory</strong></h3><p>SqlSessionFactory是每个MyBatis应用的核心<br>作用：创建SqlSession实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  openSession( <span class="keyword">boolean</span> autoCommit )	</span><br><span class="line"><span class="comment">//true ：关闭事务控制(默认)</span></span><br><span class="line"><span class="comment">//false：开启事务控制</span></span><br></pre></td></tr></table></figure>

<p>生命周期与应用的生命周期相同</p>
<p>单例 : 存在于整个应用运行时，并且同时只存在一个对象实例</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a><strong>SqlSession</strong></h3><p>包含了执行SQL所需的所有方法<br>非线程安全，不能共享<br>对应一次数据库会话，会话结束必须关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建SqlSession实例</span></span><br><span class="line">SqlSession sqlSession = MyBatisUtil.createSqlSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. do work</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 3. 关闭SqlSession//关闭SqlSession非常重要，必须要确保在finally方法体中正常关闭</span></span><br><span class="line">    MyBatisUtil.closeSqlSession(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个SqlSession实例可以执行多次SQL语句</strong></p>
<p><strong>SqlSession的两种使用方式</strong></p>
<ol>
<li>通过 namespace+id 字符串运行映射的SQL语句</li>
<li>基于Mapper接口方式执行SQL语句</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>非集成环境下的最佳实践<ol>
<li>SqlSessionFactoryBuilder的最佳使用范围是什么？<ol>
<li>用过即丢</li>
<li>推荐作用域范围：局部变量</li>
</ol>
</li>
<li>SqlSessionFactory的最佳使用范围是什么？<ol>
<li>生命周期与应用的生命周期相同</li>
<li>最佳作用域范围：应用的全局作用域</li>
</ol>
</li>
<li>SqlSession的最佳使用范围是什么？<ol>
<li>线程级</li>
<li>一个request请求期间</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h2><h3 id="主要元素"><a href="#主要元素" class="headerlink" title="主要元素"></a>主要元素</h3><p>configuration        根节点<br>    <strong>properties                  描述一些外部的、可替代的属性</strong><br>    <strong>settings                      修改MyBatis的运行时行为</strong><br>    <strong>typeAliases            为Java类型指定一个别名</strong><br>    typeHandlers             类型处理器<br>    objectFactory             对象工厂<br>    plugins                       插件<br>    <strong>environments             环境配置<br>        environment                       一组环境配置<br>            transactionManager   事务管理器<br>            dataSource                 数据源</strong><br>    databaseIdProvider    启用多数据库厂商支持<br>    <strong>mappers                     映射器</strong></p>
<h3 id="配置properties元素"><a href="#配置properties元素" class="headerlink" title="配置properties元素"></a>配置properties元素</h3><h4 id="配置properties元素的两种方式"><a href="#配置properties元素的两种方式" class="headerlink" title="配置properties元素的两种方式"></a>配置properties元素的两种方式</h4><h5 id="通过指定外部属性文件"><a href="#通过指定外部属性文件" class="headerlink" title="通过指定外部属性文件"></a>通过指定外部属性文件</h5><p>如：database.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties  resource=&quot;database.properties&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="直接配置property子节点"><a href="#直接配置property子节点" class="headerlink" title="直接配置property子节点"></a>直接配置property子节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;property  name=&quot;driver&quot;  value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;</span><br><span class="line">	&lt;property  name=&quot;url&quot;  value=&quot;jdbc:mysql://127.0.0.1:3306/……&quot; /&gt;</span><br><span class="line">	&lt;property  name=&quot;user&quot;  value=&quot;root&quot; /&gt;</span><br><span class="line">	&lt;property  name=&quot;password&quot;  value=&quot;123456&quot; /&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<h4 id="若两种方式同时都用了，哪种方式生效？"><a href="#若两种方式同时都用了，哪种方式生效？" class="headerlink" title="若两种方式同时都用了，哪种方式生效？"></a>若两种方式同时都用了，哪种方式生效？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=&quot;database.properties&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/……&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<h5 id="resource属性值会覆盖property子节点配置的同名属性值"><a href="#resource属性值会覆盖property子节点配置的同名属性值" class="headerlink" title="resource属性值会覆盖property子节点配置的同名属性值"></a>resource属性值会覆盖property子节点配置的同名属性值</h5><h2 id="settings元素"><a href="#settings元素" class="headerlink" title="settings元素"></a>settings元素</h2><p>用来修改MyBatis运行时的行为方式</p>
<p>主要是MyBatis的一些全局配置属性的设置</p>
<table>
<thead>
<tr>
<th>设置项</th>
<th>描述</th>
<th>允许值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>cacheEnabled</td>
<td>对在此配置文件下的所有cache  进行全局性开/关设置</td>
<td>true  | false</td>
<td>true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>全局性设置懒加载。如果设为false，则所有相关联的都会被初始化加载</td>
<td>true  | false</td>
<td>true</td>
</tr>
<tr>
<td>autoMappingBehavior</td>
<td>MyBatis自动映射匹配级别</td>
<td>NONE  |  PARTIAL  |  FULL</td>
<td>PARTIAL</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定MyBatis应使用的日志记录实现。如果不设置将自动发现日志记录实现</td>
<td>SLF4J  | LOG4J | LOG4J2 |  ……</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="typeAliases元素"><a href="#typeAliases元素" class="headerlink" title="typeAliases元素"></a>typeAliases元素</h2><p>类型别名<br>在SQL映射文件中简化冗长的Java类名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;SysUser&quot; type=&quot;cn.cvs.pojo.SysUser&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;package name =&quot;cn.cvs.pojo&quot; /&gt;&lt;!--默认名称：指定包下JavaBean的非限定类名--&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<h2 id="environments元素"><a href="#environments元素" class="headerlink" title="environments元素"></a>environments元素</h2><ol>
<li>environments元素<ol>
<li>可以通过environment子元素节点配置MyBatis的多套运行环境</li>
<li>必须通过default属性指定其中一个为默认运行环境</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt; &lt;!--默认的运行环境 ID--&gt;</span><br><span class="line">	&lt;environment id=&quot;development&quot;&gt;&lt;!--运行环境 ID--&gt;</span><br><span class="line">		&lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--事务管理器配置--&gt;</span><br><span class="line">		&lt;dataSource type=&quot;POOLED&quot;&gt;&lt;!--数据源配置--&gt;</span><br><span class="line">			&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;username&quot; value=&quot;$&#123;user&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">		&lt;/dataSource&gt;</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">	&lt;environment id=&quot;test&quot;&gt;&lt;!--运行环境 ID--&gt;</span><br><span class="line">		……</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>事务管理器transactionManager</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot; /&gt;</span><br><span class="line">                          &lt;!-JDBC     MANAGED（托管）  ---&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>dataSource</p>
<ol>
<li>dataSource元素使用基本的JDBC数据源接口来配置JDBC连接对象的资源</li>
<li>有三种内建的数据源类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type=&quot;[UNPOOLED|POOLED|JNDI]&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="mappers元素"><a href="#mappers元素" class="headerlink" title="mappers元素"></a>mappers元素</h2><p>SQL映射文件定义SQL语句映射<br>须在配置中引用SQL映射文件</p>
<h3 id="方式一：使用类资源路径获取资源"><a href="#方式一：使用类资源路径获取资源" class="headerlink" title="方式一：使用类资源路径获取资源"></a>方式一：使用类资源路径获取资源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">     &lt;mapper  resource=&quot;cn/cvs/dao/sysUser/SysUserMapper.xml&quot; /&gt;</span><br><span class="line">     ……</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<h3 id="方式二：使用Mapper接口的包路径"><a href="#方式二：使用Mapper接口的包路径" class="headerlink" title="方式二：使用Mapper接口的包路径"></a>方式二：使用Mapper接口的包路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 要求SQL映射文件与Mapper接口位于同一包路径下，并且名称相同 --&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">     &lt;package  name=&quot;cn.cvs.dao&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2021/11/17/%E5%88%9D%E5%A7%8BMyBatis%E6%A1%86%E6%9E%B6/image-20211117192456398.png" alt="image-20211117192456398"></p>
]]></content>
      <categories>
        <category>Java开发之SSM企业轻量级开发框架</category>
      </categories>
  </entry>
  <entry>
    <title>初始jQuery</title>
    <url>/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/</url>
    <content><![CDATA[<h1 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h1><ol>
<li><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><ol>
<li>jQuery由美国人John Resig于2006年创建</li>
<li>jQuery是目前最流行的JavaScript程序库，它是对JavaScript对象和函数的封装</li>
<li>它的设计思想是write less,do more</li>
</ol>
</li>
</ol>
<span id="more"></span>

<ol>
<li><h2 id="jQuery与JavaScript"><a href="#jQuery与JavaScript" class="headerlink" title="jQuery与JavaScript"></a>jQuery与JavaScript</h2><ol>
<li><p>jQuery是JavaScript的程序库之一，它是JavaScript对象和实用函数的封装</p>
</li>
<li><p>实现隔行变色效果，只需一句关键代码</p>
<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718153121263.png" alt="image-20210718153121263"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;tr:even&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;#e8f0f2&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>jQuery制作交互特效的语法更为简单，代码量大大减少了</p>
</li>
<li><p><strong>jQuery只是JavaScript的程序库，相当于JavaScript技术的一个子集，所有它并不能完全取代JavaScript。</strong></p>
</li>
</ol>
</li>
<li><h2 id="jQuery能做什么"><a href="#jQuery能做什么" class="headerlink" title="jQuery能做什么"></a>jQuery能做什么</h2><ol>
<li>访问和操作DOM元素</li>
<li>控制页面样式</li>
<li>对页面事件进行处理</li>
<li>扩展新的jQuery插件</li>
<li>与Ajax技术完美结合</li>
<li>jQuery能做的JavaScript也都能做，但使用jQuery能大幅提高开发效率</li>
</ol>
</li>
<li><h2 id="jQuery的优势"><a href="#jQuery的优势" class="headerlink" title="jQuery的优势"></a>jQuery的优势</h2><ol>
<li>体积小，压缩后只有100KB左右</li>
<li>强大的选择器</li>
<li>出色的DOM封装</li>
<li>可靠的事件处理机制</li>
<li>出色的浏览器兼容性</li>
<li>使用隐式迭代简化编程</li>
<li>丰富的插件支持</li>
</ol>
</li>
<li><h2 id="jQuery库文件"><a href="#jQuery库文件" class="headerlink" title="jQuery库文件"></a>jQuery库文件</h2><ol>
<li><p>jQuery库分开发版和发布版</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>jquery-1.版本号.js（开发版）</td>
<td>约286KB</td>
<td>完整无压缩版本，主要用于测试、学习和开发</td>
</tr>
<tr>
<td>jquery-1.版本号.min.js（发布版）</td>
<td>约94.8KB</td>
<td>经过工具压缩或经过服务器开启Gzip压缩，主要应用于发布的产品和项目</td>
</tr>
</tbody></table>
</li>
<li><p>在页面中引入jQuery</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/jquery-1.12.4.js&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h1><ol>
<li><h2 id="使用jQuery弹出提示框"><a href="#使用jQuery弹出提示框" class="headerlink" title="使用jQuery弹出提示框"></a>使用jQuery弹出提示框</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//为页面加载事件绑定方法 </span></span><br><span class="line">        alert(<span class="string">&quot;我欲奔赴沙场征战jQuery，势必攻克之！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><h2 id="document-ready"><a href="#document-ready" class="headerlink" title="$(document).ready()"></a><strong>$(document).ready()</strong></h2><ol>
<li><strong>$(document).ready()</strong> 与 <strong>window.onload</strong> 类似，但也有区别</li>
</ol>
<table>
<thead>
<tr>
<th>————————————–</th>
<th>window.onload</th>
<th>$(document).ready()</th>
</tr>
</thead>
<tbody><tr>
<td>执行时机</td>
<td>必须等待网页中所有的内容加载完毕后（包括图片、flash、视频等）才能执行</td>
<td>网页中所有DOM文档结构绘制完毕后即刻执行，可能与DOM元素关联的内容（图片、flash、视频等）并没有加载完</td>
</tr>
<tr>
<td>编写个数</td>
<td>同一页面不能同时编写多个</td>
<td>同一页面能同时编写多个</td>
</tr>
<tr>
<td>简化写法</td>
<td>无</td>
<td>$(function(){     //执行代码  }) ;</td>
</tr>
</tbody></table>
</li>
<li><h2 id="jQuery语法结构"><a href="#jQuery语法结构" class="headerlink" title="jQuery语法结构"></a>jQuery语法结构</h2>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(selector).action() ; </span><br></pre></td></tr></table></figure>

<ol>
<li><p>工厂函数$()：将DOM对象转化为jQuery对象</p>
<ol>
<li>在jQuery中， 美元符号“$”等价于jQuey. 即$( )=Quey( )。$()的作用是将DOM对象转化为Qnery对象，只有将DOM对象转化为jQuey对象后，才能使用jQuery的方法。</li>
<li>例如，示例1中的documen是一个DOM对象，当它使用S( )函数包裹起来时，就变成了一个jQuery对象，它能使用jQuery中的rady( )方法.而不能再使用DOM对象的geElemenByld( )方法。例如.代码$ (document) .getElementByld( )和document. ready( )均是不正确的。</li>
<li>规范当$()的参数是DOM对象时，该对象无须使用双引号包裹起来，如果获取的是document 对象，则写作$(document)。</li>
</ol>
</li>
<li><p>选择器 selector：获取需要操作的DOM 元素</p>
<ol>
<li><p>jQuery支持CSS 1.0到CSS 3.0规则中几乎所有的选择器.如标签选择器.类选择器、1ID 选择和后代选择器等，使用jQuey选择器和S( )工厂函数可以非常方便地获取需要操作的DOM元素，语法格式如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ (selector)</span><br></pre></td></tr></table></figure></li>
<li><p>ID选择器、标签选择器、 类选择器的用法如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ (<span class="string">&quot;#userName&quot;</span>) ;   <span class="comment">//获取DOM中id为userName的元素</span></span><br><span class="line">$ (<span class="string">&quot;div&quot;</span>) ;    		<span class="comment">//获取DOM中所有的div元素</span></span><br><span class="line">$ (<span class="string">&quot;. content&quot;</span>) ;  	<span class="comment">//获取DOM中class为content的元素</span></span><br></pre></td></tr></table></figure>

<p>jOuey中提供的选择器远不止上述几种，在以后的章节中将进行更加系统的介绍。</p>
</li>
</ol>
</li>
<li><p>方法action()：jQuery中提供的方法，其中包括绑定事件处理的方法</p>
<ol>
<li>jQuery中提供了一系列方法。在这些方法中，一类重要的方法就是事件处理方法，主要用来绑定DOM元素的事件和事件处理方法。在jQuery中，许多基础的事件，如鼠标事件、键盘事件和表单事件等，都可以通过这些事件方法进行绑定，对应的在jQuery 中则写作click( )、mouseover( )和mouseout( )等。</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="jQuery操作页面元素"><a href="#jQuery操作页面元素" class="headerlink" title="jQuery操作页面元素"></a>jQuery操作页面元素</h2><ol>
<li><p>使用addClass( )方法为元素添加样式</p>
<ol>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery 对象.addClass([样式名]);</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#current&quot;</span>).addClass(<span class="string">&quot;current&quot;</span>);      </span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718155322438.png" alt="image-20210718155322438"></p>
</li>
</ol>
</li>
<li><p>使用css( )方法设置元素样式</p>
<ol>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">css(<span class="string">&quot;属性&quot;</span>,<span class="string">&quot;属性值&quot;</span>) ;							<span class="comment">//设置一个CSS属性</span></span><br><span class="line">css(&#123;<span class="string">&quot;属性1&quot;</span>:<span class="string">&quot;属性值1&quot;</span>,<span class="string">&quot;属性2&quot;</span>:<span class="string">&quot;属性值2&quot;</span>...&#125;) ;	 <span class="comment">//同时设置多个CSS属性</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">this</span>).css(&#123;<span class="string">&quot;background&quot;</span>:<span class="string">&quot;#c81623&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718155514742.png" alt="image-20210718155514742"></p>
</li>
</ol>
</li>
<li><p>使用show( )、hide( ) 方法设置元素的显示和隐藏</p>
<ol>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(selector).show( );	<span class="comment">//()里是延迟</span></span><br><span class="line">$(selector).hide( );	<span class="comment">//()里是延迟</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.nav-top&quot;</span>).show( );</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).hide( );</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h2 id="jQuery代码风格"><a href="#jQuery代码风格" class="headerlink" title="jQuery代码风格"></a>jQuery代码风格</h2><ol>
<li><h3 id="“-”等同于“-jQuery-”"><a href="#“-”等同于“-jQuery-”" class="headerlink" title="“$”等同于“ jQuery ”"></a>“$”等同于“ jQuery ”</h3><ol>
<li><p>~~~js<br>$(document).ready()=jQuery(document).ready()<br>$(function(){…})=jQuery (function(){…})      </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ### 链式操作</span><br><span class="line"></span><br><span class="line">   1. 在对DOM元素进行多个操作时，为了避免过度使用临时变量或不必要的重复代码，在大多数jQuery代码中采用了一种链式编程模式。它可以对一个对象进行多重操作，并将操作结果返回给该对象，以便于将返回结果应用于该对象的下一次操作。</span><br><span class="line"></span><br><span class="line">   2. 对一个对象进行多重操作，并将操作结果返回给该对象</span><br><span class="line"></span><br><span class="line">      ~~~js</span><br><span class="line">       $(&quot;h2&quot;).css(&quot;background-color&quot;,&quot;#ccffff&quot;).next().css(&quot;display&quot;,&quot;block&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718160422713.png" alt="image-20210718160422713"></p>
</li>
</ol>
</li>
<li><h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><ol>
<li><p>在jQuery编写中，除了链式操作外，还有一种方式，即隐式迭代，</p>
</li>
<li><p>获取所有1i标签，并设置字体样式。如果在传统的JavaScript写法中，需要使用getElementsByTagName( )获取li标签集合，然后使用for循环一个一个设置字样样式，而这里使用jQuery就不一样了。它不需要遍历所有元素，可以直接设置元素的样式，这就是隐式迭代，在jQuery中获取一个集合后会默认遍历内部的所有元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       $(<span class="string">&quot;li&quot;</span>).css(&#123;<span class="string">&quot;font-weight&quot;</span>:<span class="string">&quot;bold&quot;</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;red&quot;</span>&#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718160859199.png" alt="image-20210718160859199"></p>
</li>
</ol>
</li>
<li><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>开发阶段</td>
<td>为代码添加注释，可以增加代码的可读性，能够让别人很容易的读懂你的代码，便于后期维护</td>
</tr>
<tr>
<td>维护阶段</td>
<td>建议把关键的模块形成开发文档，便于后期维护，即便后期删除代码注释，也不影响后期维护</td>
</tr>
<tr>
<td>产品正式发布</td>
<td>建议删除注释，减少文件大小，加快下载速度，提高用户体验</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h1 id="DOM对象和jQuery对象"><a href="#DOM对象和jQuery对象" class="headerlink" title="DOM对象和jQuery对象"></a>DOM对象和jQuery对象</h1><ol>
<li><h2 id="DOM模型"><a href="#DOM模型" class="headerlink" title="DOM模型"></a>DOM模型</h2><ol>
<li><p>浏览器把HTML文档的元素转换成节点对象，所有节点组成了一个树状结构</p>
<p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718161437470.png" alt="image-20210718161437470"></p>
</li>
</ol>
</li>
<li><p><strong>DOM对象</strong>：直接使用JavaScript获取的节点对象</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objDOM=<span class="built_in">document</span>.getElementById(<span class="string">&quot;title&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objHTML=objDOM.innerHTML;  </span><br></pre></td></tr></table></figure></li>
<li><p><strong>jQuery对象</strong>：使用jQuery包装DOM对象后产生的对象，它能够使用jQuery中的方法</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#title&quot;</span>).html( );</span><br><span class="line">等同于</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;title&quot;</span>).innerHTML; </span><br></pre></td></tr></table></figure>

<pre><code>**DOM对象和jQuery对象分别拥有一套独立的方法，不能混用**
</code></pre>
</li>
<li><p><strong>DOM对象转jQuery对象</strong></p>
<ol>
<li><p>使用$()函数进行转化：$(DOM对象)</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txtName =<span class="built_in">document</span>.getElementById(<span class="string">&quot;txtName&quot;</span>); <span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $txtName =$(txtName);  <span class="comment">//jQuery对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ol>
<li>jQuery对象命名一般约定以$开头</li>
<li>在事件中经常使用$(this)，this是触发该事件的对象</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>jQuery对象转DOM对象</strong></p>
<ol>
<li><p>jQuery对象是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $txtName =$ (<span class="string">&quot;#txtName&quot;</span>); <span class="comment">//jQuery对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> txtName =$txtName[<span class="number">0</span>]; <span class="comment">//DOM对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过get(index)方法得到相应的DOM对象</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $txtName =$(<span class="string">&quot;#txtName&quot;</span>); <span class="comment">//jQuery对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> txtName =$txtName.get(<span class="number">0</span>);<span class="comment">//DOM对象  </span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2021/07/18/%E5%88%9D%E5%A7%8BjQuery/image-20210718161923661.png" alt="image-20210718161923661"></p>
]]></content>
      <categories>
        <category>使用jQuery快速高效制作网页交互特效</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 对象和封装</title>
    <url>/2021/06/04/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="一、为什么使用面向对象"><a href="#一、为什么使用面向对象" class="headerlink" title="一、为什么使用面向对象"></a>一、为什么使用面向对象</h1><h2 id="1、软件出现的目的"><a href="#1、软件出现的目的" class="headerlink" title="1、软件出现的目的"></a>1、软件出现的目的</h2><p>用计算机的语言描述现实世界</p>
<p>用计算机解决现实世界的问题</p>
<h2 id="2、面向对象设计和开发程序的好处"><a href="#2、面向对象设计和开发程序的好处" class="headerlink" title="2、面向对象设计和开发程序的好处"></a>2、面向对象设计和开发程序的好处</h2><p>交流更加流畅</p>
<p>提高设计和开发效率</p>
<span id="more"></span>

<h2 id="3、然后从现实中抽出类分三步"><a href="#3、然后从现实中抽出类分三步" class="headerlink" title="3、然后从现实中抽出类分三步"></a>3、然后从现实中抽出类分三步</h2><h3 id="1-找出它的种类"><a href="#1-找出它的种类" class="headerlink" title="1.找出它的种类"></a>1.找出它的种类</h3><p>面向对象的思想描述世界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-找出它的属性"><a href="#2-找出它的属性" class="headerlink" title="2.找出它的属性"></a>2.找出它的属性</h3><h3 id="3-找出它的行为"><a href="#3-找出它的行为" class="headerlink" title="3.找出它的行为"></a>3.找出它的行为</h3><h1 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h1><p>在完成构造方法同时完成了属性的赋值   <strong>什么时候用：new的时候用</strong></p>
<h2 id="1、构造方法语法"><a href="#1、构造方法语法" class="headerlink" title="1、构造方法语法"></a>1、构造方法语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符   构造方法名 ( ) &#123; </span><br><span class="line">       <span class="comment">//初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法：无返回值类型       </p>
<p>构造方法名：  与类名相同</p>
<p>括号里可以指定参数</p>
<h2 id="2、注意"><a href="#2、注意" class="headerlink" title="2、注意"></a>2、注意</h2><p>系统会默认提供无参构造方法</p>
<p>如果写构造方法，系统就不自动提供无参构造方法</p>
<h2 id="3、构造方法的重载"><a href="#3、构造方法的重载" class="headerlink" title="3、构造方法的重载"></a>3、构造方法的重载</h2><p>this 关键字是对应该对象的默认引用，这里用以区分同名成员变量</p>
<p>如何用调用构造方法的重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pgn = <span class="keyword">new</span> Penguin();</span><br><span class="line">pgn.print();</span><br><span class="line">pgn = <span class="keyword">new</span> Penguin(<span class="string">&quot;美美&quot;</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="string">&quot;Q仔&quot;</span>);</span><br><span class="line">pgn.print();</span><br></pre></td></tr></table></figure>

<h2 id="4、static关键字"><a href="#4、static关键字" class="headerlink" title="4、static关键字"></a>4、static关键字</h2><h3 id="1、为什么要用static关键字"><a href="#1、为什么要用static关键字" class="headerlink" title="1、为什么要用static关键字"></a>1、为什么要用static关键字</h3><p>直接用类名.变量名 类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.变量名</span><br></pre></td></tr></table></figure>

<p>2、final修饰词<br>用fianl修饰的变量称为常量，其值固定不变</p>
<p>被final修饰的变量通常称为常量</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>static、非private修饰</strong></th>
<th><strong>非static、prvate修饰</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>属性</strong></td>
<td>类属性、类变量</td>
<td>实例属性、实例变量</td>
</tr>
<tr>
<td><strong>方法</strong></td>
<td>类方法</td>
<td>实例方法</td>
</tr>
<tr>
<td><strong>调用方法</strong></td>
<td>类名.属性</td>
<td>对象.属性,对象.方法（）</td>
</tr>
<tr>
<td><strong>调用方法</strong></td>
<td>类名.方法（）</td>
<td>对象.属性,对象.方法（）</td>
</tr>
<tr>
<td><strong>调用方法</strong></td>
<td>对象，属性</td>
<td>对象.属性,对象.方法（）</td>
</tr>
<tr>
<td><strong>调用方法</strong></td>
<td>对象.方法（）</td>
<td>对象.属性,对象.方法（）</td>
</tr>
<tr>
<td><strong>归属</strong></td>
<td>类</td>
<td>单个对象</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>切记不可定义为static变量</p>
<h1 id="三、什么是封装"><a href="#三、什么是封装" class="headerlink" title="三、什么是封装"></a>三、什么是封装</h1><h2 id="1、面想对象三大特征之一——封装"><a href="#1、面想对象三大特征之一——封装" class="headerlink" title="1、面想对象三大特征之一——封装"></a>1、面想对象三大特征之一——封装</h2><h3 id="（1）封装的概念"><a href="#（1）封装的概念" class="headerlink" title="（1）封装的概念"></a>（1）封装的概念</h3><p>封装：将类的某些信息隐藏的类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p>
<h3 id="（2）封装的好处"><a href="#（2）封装的好处" class="headerlink" title="（2）封装的好处"></a>（2）封装的好处</h3><p>1.隐藏类的实现细节</p>
<p>2.方便加入控制语句</p>
<p>3.方便修改实现</p>
<p>4.只能通过规定的方法访问数据</p>
<h3 id="（3）封装的步骤"><a href="#（3）封装的步骤" class="headerlink" title="（3）封装的步骤"></a>（3）封装的步骤</h3><p>1.修改属性的可见性——设置为private</p>
<p>2.创建共有的getter/setter方法——用于属性的读写</p>
<p>3.在getter/setter方法说中加入属性控制的语句——对属性值的合法性进行判断</p>
<h2 id="2、this关键词的用法"><a href="#2、this关键词的用法" class="headerlink" title="2、this关键词的用法"></a>2、this关键词的用法</h2><h3 id="（1）调用属性"><a href="#（1）调用属性" class="headerlink" title="（1）调用属性"></a>（1）调用属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.health=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">this</span>.name=<span class="string">&quot;大黄&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="（2）调用方法"><a href="#（2）调用方法" class="headerlink" title="（2）调用方法"></a>（2）调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.print();</span><br></pre></td></tr></table></figure>

<h3 id="（3）调用构造方法"><a href="#（3）调用构造方法" class="headerlink" title="（3）调用构造方法"></a>（3）调用构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>();</span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;小黑&quot;</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="string">&quot;雄&quot;</span>);<span class="comment">//如果使用，必须是构造方法 中的第一条语句</span></span><br></pre></td></tr></table></figure>

<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p> <img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511722.png" alt="第一章 对象和封装"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第七章 多线程</title>
    <url>/2021/06/04/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><h3 id="1-什么是进程："><a href="#1-什么是进程：" class="headerlink" title="1.什么是进程："></a>1.什么是进程：</h3><p>​    继承是程序的一次动态执行过程，他对应了从代码加载、执行至完成的一个完整过程，这个过程也是程序本身从产生、发展至消亡的过程。</p>
<p>​    操作系统同时管理一个计算机系统中的多个进程，让计算机系统中的多个进程轮流使用CPU资源，或者共享操作系统的其他资源。</p>
<span id="more"></span>

<h3 id="2-进程的特点："><a href="#2-进程的特点：" class="headerlink" title="2.进程的特点："></a>2.进程的特点：</h3><ul>
<li><p> 继承是系统运行程序的基本单位。</p>
</li>
<li><p>每一个进程都有自己独立的一块内存空间，一组系统资源。</p>
</li>
<li><p>每一个进程的内部数据和状态都是完全独立的。</p>
</li>
</ul>
<h2 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h2><h3 id="1-什么是线程："><a href="#1-什么是线程：" class="headerlink" title="1.什么是线程："></a>1.什么是线程：</h3><p>​    线程是进程中执行运算的最小单位，可完成一个独立的顺序控制流程。每个进程中，必须至少建立一个线程（这个线程成为主线程）来作为这个程序的入口点。</p>
<p>​    如果在一个进程中同时运行多个线程来完成不同的工作，称之为“多线程”。    是多个线程共享相同的地址空间并且共同分享同一个进程    ，这些进程可以在操作系统的管理下并发执行。</p>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><h3 id="1-什么是多线程"><a href="#1-什么是多线程" class="headerlink" title="1.什么是多线程"></a>1.什么是多线程</h3><ul>
<li>充分利用CPU资源：执行单线程程序时，若程序发生阻塞，CPU可能会处于空闲状态，这将会造成计算机资源浪费，而使用多线程可以在某个线程处理休眠或阻塞状态时运行其他线程，这样大大提高了资源利用率。</li>
<li>简化编程模型：一个即长又复杂的进程可以分为多个线程，成为几个独立的运行部分，如果写成单线程程序可能需要多重循环判断，而如果使用多线程控制，每个线程仅需要实现简单的流程，简化了程序逻辑。</li>
<li>带来良好的用户体验：由于多个线程可以交替执行，减少避免了因程序阻塞或意外情况造成的响应过慢现象。</li>
</ul>
<h3 id="2-如何实现多线程"><a href="#2-如何实现多线程" class="headerlink" title="2.如何实现多线程"></a>2.如何实现多线程</h3><p> 用 <strong>Thread</strong> 类      <strong>Thread</strong> 类支持多线程</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Thread（）</strong></td>
<td>分配新的 <strong>Thread（）</strong> 对象</td>
</tr>
<tr>
<td><strong>Thread（Runnable targe）</strong></td>
<td>分配新的 <strong>Thread（）</strong> 对象， <strong>target</strong> 为 <strong>run（）</strong> 方法被调用的对象</td>
</tr>
<tr>
<td><strong>Thread（Runnable targe，String name）</strong></td>
<td>分配新的 <strong>Thread（）</strong> 对象， <strong>target</strong> 为 <strong>run（）</strong> 方法被调用的对象，<strong>name</strong> 作为新线程的名称</td>
</tr>
<tr>
<td><strong>void run（）</strong></td>
<td>执行任务操作的方法</td>
</tr>
<tr>
<td><strong>void start（）</strong></td>
<td>使线程开始执行，Java虚拟机代用该线程的 <strong>run（）</strong> 方法</td>
</tr>
<tr>
<td><strong>void sleep(long millis)</strong></td>
<td>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</td>
</tr>
<tr>
<td><strong>String getName（）</strong></td>
<td>返回线程的名称</td>
</tr>
<tr>
<td><strong>int getPriorty（）</strong></td>
<td>返回线程的优先级</td>
</tr>
<tr>
<td><strong>void setPriority（int newPriority）</strong></td>
<td>更改线程的优先级</td>
</tr>
<tr>
<td><strong>static Thread currentThread（）</strong></td>
<td>返回当前正在执行的线程对象的引用</td>
</tr>
<tr>
<td><strong>boolean isAlive（）</strong></td>
<td>测速线程是否属于活动状态</td>
</tr>
<tr>
<td><strong>void join（）</strong></td>
<td>等待该线程终止</td>
</tr>
<tr>
<td><strong>void interrupt</strong></td>
<td>中断线程</td>
</tr>
<tr>
<td><strong>void yield（）</strong></td>
<td>暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
</tbody></table>
<h3 id="3-主线程"><a href="#3-主线程" class="headerlink" title="3.主线程"></a>3.主线程</h3><p>​    每个进程至少有一个主线程。他是从程序开始的时候开始执行的。</p>
<ol>
<li><h4 id="主线程的重要性主要体现在以下两个方面"><a href="#主线程的重要性主要体现在以下两个方面" class="headerlink" title="主线程的重要性主要体现在以下两个方面"></a>主线程的重要性主要体现在以下两个方面</h4></li>
</ol>
<ul>
<li>他是产生其他子线程的线程</li>
<li>通常它必须最后完成执行，因为它执行各种关闭动作</li>
</ul>
<ol start="2">
<li><h4 id="如何使用线程"><a href="#如何使用线程" class="headerlink" title="如何使用线程"></a>如何使用线程</h4><ol>
<li><h5 id="定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能"><a href="#定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能" class="headerlink" title="定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能"></a>定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能</h5></li>
<li><h5 id="创建线程对象"><a href="#创建线程对象" class="headerlink" title="创建线程对象"></a>创建线程对象</h5><p>创建线程类两种方法，一种是继承 <strong>Thread</strong> 类，另一种是实现 <strong>Runnable</strong> 接口。</p>
<ol>
<li> 继承 <strong>Thread</strong> 类创建线程</li>
<li>需要重写 <strong>Thread</strong> 类并重写 <strong>Thread</strong> 类的 <strong>run（）</strong> 方法。因为 <strong>Thread</strong> 类的 <strong>run（）</strong> 方法是线程要执行操作任务，所以线程要执行的操作代码都要写在 <strong>run（）</strong> 方法中，并通过调用 <strong>start（）</strong> 方法启动线程后调用。</li>
<li>实现 <strong>Runnable</strong> 接口创建线程<ol>
<li>  <strong>Runnable</strong> 接口定义在 <strong>java.lang</strong> 包中，其中声明了一个抽象方法 <strong>run（）</strong> ，即 <strong>public void run（）</strong> ，一个类可以同实现 <strong>Runnable</strong> 接口并实现其 <strong>run（）</strong> 方法完成线程的活动，已实现的 <strong>run（）</strong> 方法成为该线程的线程体。任何实现 <strong>Runnable</strong> 接口的对象都可以作为一个线程的目标对象。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h5></li>
<li><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5></li>
</ol>
</li>
<li><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>如何线程都具有五种状态，即创建，就绪，运行，阻塞，死亡状态。</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510361.png" alt="线程的状态"></p>
<ol>
<li><p>创建状态</p>
<pre><code>     - 在程序中用构造方法创建了一个线程对象后，新的线程对象就处于创建状态，此时，他已经获取了相应的资源，但还没有处于可运行的状态，这时可以通过 **Thread** 类的方法来设置线程对象的属性。如线程名，设置线程的优先级等。
</code></pre>
</li>
<li><p>就绪状态</p>
<ul>
<li>线程创建玩之后，就可以通过调用 <strong>start（）</strong> 方法启动线程，即进入就绪状态，此时，线程将进入线程队列排队，等待CPU资源，这表明他已经具备了运行条件，在未获得CPU资源时，仍然不能真正执行。</li>
</ul>
</li>
<li><p>运行状态</p>
<ul>
<li>当就绪状态的线程获得CPU资源时，即可转入运行状态，执行 <strong>run（）</strong> 方法。对只有一个CPU的计算机而言，任何时空只能有一个处于运行状态的线程占用CPU，即获得CPU资源。</li>
</ul>
</li>
<li><p>阻塞状态</p>
<ul>
<li><p>一个正在运行的线程因某种原因不能继续运行时，进入阻塞庄园。阻塞状态时一种“不可运行”的状态，而处于这种状态的线程在得到一个特定的事件后转回可运行状态。</p>
</li>
<li><p>可能使线程暂停执行的条件如下：</p>
<ul>
<li>由于线程的优先级比较低，因此他不能获得CPU资源。</li>
<li>使用 <strong>slept（）</strong> 方法使线程休眠</li>
<li>通过调用 <strong>wait（）</strong> 方法，使线程等待</li>
<li>通过调用 <strong>yield（）</strong> 线程显式让出CPU控制权。</li>
<li>线程由于等待一个文件，I/O事件被阻塞</li>
</ul>
</li>
</ul>
<ol start="5">
<li>死亡状态<ul>
<li>一个线程的 <strong>run（）</strong> 方法运行完毕，线程则进入死亡状态，处于死亡状态的线程不具有继续运行的能力。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="4-线程的优先级"><a href="#4-线程的优先级" class="headerlink" title="4.线程的优先级"></a>4.线程的优先级</h4><p>​    懂同一时刻有一个或得个线程处于可运行状态时，他们需要排队等待CPU资源，每个线程会自动获得一个线程的优先级，优先级的高低反映线程的重要或紧急程度。</p>
<p>​    线程的优先级用1~10表示，1表示优先级最低，10表示优先级最高，默认值是5。</p>
<h4 id="5-线程的休眠"><a href="#5-线程的休眠" class="headerlink" title="5. 线程的休眠"></a>5. 线程的休眠</h4><p>​    在程序程序组允许一个线程进行短暂休眠，直接调用 <strong>Thread.sleep()</strong> 方法即可实现线程的休眠</p>
<p>​    <strong>sleep（）</strong> 方法会让当前线程休眠（停止执行）mills毫秒，线程由运行中的状态进入不可运行状态，睡眠时间过后会再次进入就绪状态，需要判断他是否死亡 需要处理 <strong>InterruptedException</strong> 异常。</p>
<h4 id="6-线程的强制运行"><a href="#6-线程的强制运行" class="headerlink" title="6. 线程的强制运行"></a>6. 线程的强制运行</h4><p>​    <strong>join()</strong> 方法使当前的线程暂停执行，等待调用该方法的线程结束后再继续执行本线程。它有三个重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> mills)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> mills,<span class="keyword">int</span> nanos)</span></span></span><br></pre></td></tr></table></figure>

<p>需要判断他是否死亡 需要处理 <strong>InterruptedException</strong> 异常。</p>
<h4 id="7-线程的礼让"><a href="#7-线程的礼让" class="headerlink" title="7.线程的礼让"></a>7.线程的礼让</h4><p>​    <strong>yield（）</strong> 方法可以暂停当前的线程执行，允许其他线程具有相同优先级的线程获得运行机会，该线程仍处于就绪状态，不转为阻塞状态，此时相同现在其他相同或更高优先级的线程执行，如无其他相同或更高优先级的线程，则该线程继续执行。</p>
<h4 id="8-线程的同步"><a href="#8-线程的同步" class="headerlink" title="8.线程的同步"></a>8.线程的同步</h4><p>​    有一些同时运行的线程需要共享数据，此时就需要考虑其他线程的状态和行为，否则不能保证程序运行结果的准确性。</p>
<p>​    如何实现：</p>
<p>​    一个线程类如果是通过实现 <strong>Runnable</strong> 接口实现的，那么类中的属性有可能被多个该类的线程对象共享，就有可能引发线程不同步的问题。</p>
<p>采用线程同步有两种方式 </p>
<ol>
<li><p>同步方法<br> 使用 <strong>synchronized</strong> 修饰的方法控制对类成员的访问。每个类实例对应一把锁，方法一旦执行，就独占该锁。直到从该方法返回时才将锁释放，从此以后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过哎方法声明中加入synchronized关键字来声明同步方法</span></span><br><span class="line">	访问修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名 （参数列表）&#123;<span class="comment">//省略方法体。。。。。。&#125;</span></span><br><span class="line">或者</span><br><span class="line">    <span class="keyword">synchronized</span> 访问修饰符 返回值类型 方法名 （参数列表）&#123;<span class="comment">//省略方法体。。。。。。&#125;</span></span><br></pre></td></tr></table></figure>
<p> 在语法中：</p>
<p> ​    <strong>synchronized</strong> 是同步关键词。</p>
<p> ​    访问修饰符是指 <strong>public</strong> ， <strong>private</strong> 等。</p>
</li>
<li><p>同步代码块</p>
<p> 代码块即使用{}括起来的一段代码，使用 <strong>synchronized</strong> 关键字修饰的代码块，成为同步代码块。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> （syncObject）&#123;</span><br><span class="line">	<span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>synchronized</strong> 块中的代码必须获得对象 <strong>syncObject</strong> 的锁才能执行，具体机制和代码同步一致。可以制定上锁的对象。</p>
</li>
<li><p>常见类型对比</p>
<ol>
<li><p><strong>Hashtable &amp;&amp; HashMap</strong></p>
<ul>
<li><p><strong>Hashtable</strong></p>
<p>​    1. 继承 关系</p>
<p>​        实现了<strong>Map</strong>接口，<strong>Hashtable</strong>继承<strong>Dictionary</strong>类</p>
<p>​    2. 线程安全，效率较低</p>
<p>​    3. 键和值都不允许为<strong>null</strong></p>
</li>
<li><p><strong>HashMap</strong></p>
<ol>
<li>继承关系</li>
</ol>
<p>​        实现了<strong>Map</strong>接口，继承<strong>AbstractMap</strong>类</p>
<ol start="2">
<li><p>非线程安全，效率较高</p>
</li>
<li><p>键和值都允许为<strong>null</strong></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>StringBuffer</strong> <strong>&amp;&amp;</strong> <strong>StringBuilder</strong></p>
<p> 前者线程安全，后者非线程安全</p>
</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2></li>
</ol>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510367.png" alt="第七章多线程2"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 异常</title>
    <url>/2021/06/04/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="一、什么是异常"><a href="#一、什么是异常" class="headerlink" title="一、什么是异常"></a>一、什么是异常</h2><p>​    异常就是在程序的允许过程中所发生的不正常的事件。</p>
<h2 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h2><p>​    Java的异常处理是通过五个关键词来实现的： **try、catch、finally、throw和throws ** </p>
<span id="more"></span>

<h3 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="1.try-catch"></a>1.try-catch</h3><ul>
<li>如果 <strong>try</strong> 块中所有语句正常执行完毕，不会发生异常，那么 <strong>catch</strong> 快中的所有语句都将会被忽略。</li>
<li>如果 <strong>try</strong> 语句快在执行的过程中遇到异常，并且这个异常与 <strong>catch</strong> 中声明的异常类型相匹配。那么 <strong>try</strong> 快中其余剩下的代码被忽略，而相应的 <strong>catch</strong> 快将会被执行。匹配是指catch所处理的异常类型与所生存的异常类型完全一致或是它的父类。</li>
<li>如果 <strong>try</strong> 语句块中在执行过程中遇到异常，而抛出的异常在 <strong>catch</strong> 块里面没有被声明，那么程序立即退出。<ul>
<li>报异常的方法有以下两种<ul>
<li> <strong>void printStackTrace</strong> ：输出异常的信息。信息包括程序运行到当前类的执行流程，他讲输出从方法调用到异常抛出处的方法调用序列。</li>
<li> **String getMessage ( ) ** ：返回异常信息描述字符串。该字符描述异常产生的类型，是 <strong>printStackTrace（ ）</strong> 方法输出信息的一部分。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-try-catch-finally"><a href="#2-try-catch-finally" class="headerlink" title="2.try-catch-finally"></a>2.try-catch-finally</h3><ul>
<li>在 <strong>try-catch</strong>  语句后加入 <strong>finally</strong> 快，把该语句放入 <strong>finally</strong> 块。无论是否发生异常， <strong>finally</strong> 块中的代码总能被执行。</li>
<li> <strong>try-catch-finally</strong> 程序块的执行的流程大致分为两种</li>
<li>如果 <strong>try</strong> 块中所有的语句正常执行完毕，那么 <strong>finally</strong> 块就会被执行。</li>
<li>如果 <strong>try</strong> 语句块在执行过程中碰到异常，无论这种异常能否被catch块捕获到，都将执行 <strong>finally</strong> 块中的代码</li>
<li><strong>try-catch-finally</strong> 结构中的 <strong>try</strong> 块是必需的， <strong>catch</strong> 和 <strong>fina</strong> 块为可选，但两者至少必须出现其中之一。</li>
<li>需要注意的是，即使在 <strong>try</strong> 块和 <strong>catch</strong> 块中存在 <strong>return</strong> 语句， <strong>finally</strong> 块中语句也会被执行。发生异常时的执行顺序：执行 <strong>try</strong> 块或 <strong>catch</strong> 中 <strong>return</strong> 之前的语句，执行 <strong>finally</strong> 块中的语句，执行 <strong>try</strong> 块或 <strong>catch</strong> 中的 <strong>return</strong> 语句退出。</li>
<li> <strong>finally</strong> 块中语句不被执行的唯一情况：在异常处理代码中执行 <strong>System.exit(1)</strong> ，直接退出。</li>
</ul>
<h3 id="3-多重catch块"><a href="#3-多重catch块" class="headerlink" title="3.多重catch块"></a>3.多重catch块</h3><ul>
<li><p>系统从上到下分别对每个catch语句块处理的异常类型进行检查，并执行第一个与异常类型匹配的catch语句。执行其中一条catch语句之后，其后的catch语句都将被忽略。</p>
</li>
<li><p>在使用多重 <strong>catch</strong> 块中， <strong>catch</strong> 块的排列顺序必须是从子类到父类，最后一个一般都是 <strong>Exception</strong> 父类。</p>
<h3 id="4-声明异常——throws"><a href="#4-声明异常——throws" class="headerlink" title="4.声明异常——throws"></a>4.声明异常——throws</h3></li>
<li><p>在java中用关键字 <strong>throws</strong> 声明摸个方法可能抛出的各种异常。 <strong>throws</strong> 可以同时声明多个异常，之间用逗号隔开。<strong>被声明异常之后调用必须处理异常</strong></p>
</li>
</ul>
<p>处理异常的<strong>两种</strong>方式</p>
<ul>
<li>通过 <strong>try-catch</strong> 捕获</li>
<li>通过 <strong>throws</strong> 继续声明异常。如果调用者不打算处理异常，则可以继续通过 <strong>throws</strong> 声明异常，让下一个调用者处理异常。 <strong>main()</strong> 方法声明的异常将由Java虚拟机来处理。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法名 <span class="keyword">throws</span> 异常，异常（）&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-抛出异常——throw"><a href="#5-抛出异常——throw" class="headerlink" title="5.抛出异常——throw"></a>5.抛出异常——throw</h3><p>手动抛出异常</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;错误语句&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-throw和throws的区别表现在以下三个方面"><a href="#6-throw和throws的区别表现在以下三个方面" class="headerlink" title="6.throw和throws的区别表现在以下三个方面"></a>6.throw和throws的区别表现在以下三个方面</h3><p><strong>作用不同</strong> ：<strong>throw</strong> 用于在程序中抛出异常；<strong>throws</strong> 用于声明在该方法内抛出了异常。</p>
<p><strong>使用的位置不同</strong> ：<strong>throw</strong> 位于方法体内部，都可以作为单独语句使用；<strong>throws</strong> 必须跟在方法参数列表的后面，不能单独使用。</p>
<p><strong>内容不同</strong>： <strong>throw</strong> 抛出一个异常对象，而且只能是一个；throws后面跟异常类，而且可以跟多个异常类。</p>
<h3 id="7-常见的异常类型"><a href="#7-常见的异常类型" class="headerlink" title="7.常见的异常类型"></a>7.常见的异常类型</h3><table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Exception</strong></td>
<td>异常层次结构的跟类</td>
</tr>
<tr>
<td><strong>ArithmeticException</strong></td>
<td>算术错误情形，如以零作除数</td>
</tr>
<tr>
<td><strong>ArrayIndexOutOfBoundsException</strong></td>
<td>数组下标越界</td>
</tr>
<tr>
<td><strong>NullPointerException</strong></td>
<td>尝试访问 null 对象成员</td>
</tr>
<tr>
<td><strong>ClassNotFoundException</strong></td>
<td>不能加载所需的类</td>
</tr>
<tr>
<td><strong>IllegalArgumentException</strong></td>
<td>方法接收到非法参数</td>
</tr>
<tr>
<td><strong>ClassCastException</strong></td>
<td>对象强制类型转换出错</td>
</tr>
<tr>
<td><strong>NumberFormatException</strong></td>
<td>数字格式转换异常，如把”abc”转换成数字</td>
</tr>
</tbody></table>
<h2 id="二、-异常的分类"><a href="#二、-异常的分类" class="headerlink" title="二、.异常的分类"></a>二、.异常的分类</h2><p><img src="/2021/06/04/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%BC%82%E5%B8%B8/img%5Cimage-20210528154353741.png" alt="image-20210528154353741"></p>
<p><strong>Throwable</strong> 类：所有异常都是 <strong>Throwable</strong> 类的子类，他派生两个子类，即 <strong>Error</strong> 和 <strong>Exception</strong> 。</p>
<p><strong>Error</strong> 类：表示仅靠程序本身无法恢复的严重错误，如内存溢出动态链接失败，虚拟机错误。应用程序不应该抛出这种类型的对象（一般是由虚拟机抛出的）。加入出现这种错误，除了尽力使程序安全退出为，在其他方面是无能为力的。使用在进行程序设计时，应该更关注 <strong>Exception</strong> 类。</p>
<p><strong>Exception</strong> 类：由java应用程序抛出和处理的非严重错误，如所需文件找不到、网络连接不通或终端、算书运算出错（如被零除）、数字（下标越界）、数组下标越界、装在了一个不存在的类、对null对象操作、类型转换异常等。它的各种不同的子类分半对应不同类型的异常。</p>
<p><strong>运行时异常</strong>：包括 <strong>RuntimeException</strong> 及其使用子类，不要求程序必须对题目做出处理。</p>
<p><strong>Checked</strong> 异常：（非运行时异常）除了运行时异常外的其他由Exception继承来的继承类。程序必须捕获或者声明抛出这种异常，否则会出现编译错误，无法通过编译。处理方式包括两种：通过 <strong>try-catch</strong> 捕获；通过 <strong>throws</strong> 继续声明异常，交给上一级调用方法处理。</p>
<h2 id="三、Log4j——开源日志记录工具"><a href="#三、Log4j——开源日志记录工具" class="headerlink" title="三、Log4j——开源日志记录工具"></a>三、Log4j——开源日志记录工具</h2><h3 id="1-记录的内容分为以下三种："><a href="#1-记录的内容分为以下三种：" class="headerlink" title="1.记录的内容分为以下三种："></a>1.记录的内容分为以下三种：</h3><ul>
<li>SQL日志：记录系统执行的SQL语句。</li>
<li>异常日志：记录系统运行中发生的异常事件</li>
<li>业务日志：记录系统运行过程，如用户登录，操作记录</li>
</ul>
<h3 id="2-如何使用log4j记录日志"><a href="#2-如何使用log4j记录日志" class="headerlink" title="2.如何使用log4j记录日志"></a>2.如何使用log4j记录日志</h3><p>​    （1）在项目中加入log4j的 <strong>JAR</strong> 文件 直接在项目上 Ctrl+C-Ctrl+V</p>
<p>​    （2）创建 <strong>log4j.properties</strong> 文件。</p>
<p>​    （3）编写 <strong>log4j.properties</strong> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 设置Logger输出级别和输出目的地 ###</span><br><span class="line">log4j.rootLogger=debug, stdout,logfile</span><br><span class="line"></span><br><span class="line">### 把日志信息输出到控制台 ###</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target=System.err</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.SimpleLayout</span><br><span class="line"></span><br><span class="line">### 把日志信息输出到文件：jbit.log ###</span><br><span class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.File=jbit.log</span><br><span class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %F %p %m%n</span><br></pre></td></tr></table></figure>

<p>​    （4）使用 <strong>log4j</strong> 记录日志信息</p>
<p>声明一个成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger=Logger.getLogger(类名.class.getName());</span><br></pre></td></tr></table></figure>

<h3 id="3-log4j-配置文件"><a href="#3-log4j-配置文件" class="headerlink" title="3.log4j 配置文件"></a>3.log4j 配置文件</h3><p>（1）输出级别<br>$$<br>日志记录器输出级别：fatal &gt; error &gt; warn &gt; info &gt;debug<br>$$<br><strong>fatal</strong>：指出验证的错误事件将会导致应用程序的退出</p>
<p><strong>error</strong>:指出虽然发生错误事件，但仍然不影响系统的继续运行</p>
<p><strong>warn</strong>：表明会出现潜在错误的情形</p>
<p><strong>info</strong>：在粗粒度级别上指明消息，强调应用程序的运行过程。</p>
<p><strong>debug</strong>：指出细粒度信息事件，对调试应用程序是非常有帮助的。</p>
<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511450.png" alt="log4j 配置文件"></p>
<h2 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131511331.png" alt="第五章 异常总结"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 继承</title>
    <url>/2021/06/04/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1>一 继承的一些定义</h1>
<h2>1.为什么使用继承</h2>
将重复代码抽取到父类中<br>
<h2>2.使用继承有什么优点</h2>
1)方便修改代码<br>
2)减少代码量<br>
子类和父类是is-a关系<br>

<span id="more"></span>

<h2>二 如何使用继承</h2>
<h3>编写父类</h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">	<span class="comment">//父类的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>编写子类，继承父类<h3>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;<span class="comment">//只能继承一个父类</span></span><br><span class="line">	<span class="comment">//子类特有的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java继承关键字  extends<br>C#继承关键字 ：</p>
<h3>1.子类访问父类成员<h3>

<p>使用super关键字，super代表父类对象<br><br>在子类构造方法中调用且必须是及第一句</p>
<ul>
<li>访问父类构造方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">super</span>(name);</span><br></pre></td></tr></table></figure></li>
<li>访问父类属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.name;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问父类方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.print();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3>2.子类可以继承父类的所有资源 ?<h3>

<ol>
<li>private成员</li>
<li>子类与父类不在同包</li>
<li>构造方法<h3>3.访问修饰符<h3></h3></h3></li>
</ol>
<ul>
<li>可以修饰属性和方法</li>
<li>本类、同包、子类可以访问<br><b>访问修饰符总结<b></b></b></li>
</ul>
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>本类</th>
<th>同包</th>
<th>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>prvate</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>默认（triendly）</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3>4.多重继承的关系初始化顺是怎样的？<h3>

<p>父类属性→ 父类构造方法→ 子类属性→ 子类构造方法</p>
<h3>5.何时使用继承<h3>

<ul>
<li><p>符合is-a关系的设计使用继承</p>
</li>
<li><p>将子类共有的属性和新闻哥放到父类中<br><b>继承是代码重用的一种方式<b></b></b></p>
<h1>三 方法重写<h1>
<h2>1.方法重写的规则<h2></h2></h2></h1></h1></li>
<li><p>方法名相同</p>
</li>
<li><p>参数列表相同</p>
</li>
<li><p>返回值类型相同或者是其子类</p>
</li>
<li><p>访问权限不能严与父类</p>
</li>
</ul>
<blockquote>
<p>同类 同名 不同参<br></p>
</blockquote>
<p><strong>方法重载和方法重写的异同</strong><br>||位置|方法名|参数表|返回值|访问修饰符|<br>|-|-|-|-|-|-|<br>|方法重写|子类|相同|相同|相同或是其子类|不能比父类更严格|<br>|方法重载|同类|相同|不相同|无关|无关|</p>
<h1>四 抽象类<h1>
<h2>语法<h2>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 抽象类</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 方法名();<span class="comment">//没有方法体</span></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>abstract也可以用于方法-抽象方法<b></b></b></p>
<ul>
<li>抽象方法没有方法体</li>
<li>抽象方法必须在抽象类中</li>
<li>抽象必须在子类中被实现,除非子类是抽象类</li>
</ul>
<h1>五 总结<h1>

<p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510116.png" alt="继承知识汇总"></p>
</h1></h1></h2></h2></h1></h1></h3></h3></h3></h3></h3></h3></h3></h3></h3></h3>]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 多态</title>
    <url>/2021/06/04/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="1-什么是多态"><a href="#1-什么是多态" class="headerlink" title="1.什么是多态"></a>1.什么是多态</h2><p>​    多态是具有表现多种形态的能力的特征</p>
<p>​    同一种操作，由于条件不同，产生的结果也不同</p>
<p>​    多态：同一个引用类型，使用不同的实例而执行不同操作 </p>
<p>​    多态就是子类转换成父类    父类类型new子类对象</p>
<span id="more"></span>

<h2 id="2-如何实现多态"><a href="#2-如何实现多态" class="headerlink" title="2.如何实现多态"></a>2.如何实现多态</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>​    编写具有继承关系的父类和子类<br>​    子类方法重写父类方法</p>
<h3 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h3><h4 id="使用父类作为方法形参实现多态"><a href="#使用父类作为方法形参实现多态" class="headerlink" title="使用父类作为方法形参实现多态"></a>使用父类作为方法形参实现多态</h4><ul>
<li><p>将一个父类的引用指向一个子类对象，称为向上转型（upcasting），自动进行类型转换</p>
</li>
<li><p>此时通过父类引用变量调用的是子类覆盖或继承父类的方法，不是父类的方法</p>
</li>
<li><p>此时通过父类引用变量无法调用子类特有的方法</p>
</li>
</ul>
<h4 id="使用父类作为方法返回值实现多态"><a href="#使用父类作为方法返回值实现多态" class="headerlink" title="使用父类作为方法返回值实现多态"></a>使用父类作为方法返回值实现多态</h4><h3 id="父类到子类的转换"><a href="#父类到子类的转换" class="headerlink" title="父类到子类的转换"></a>父类到子类的转换</h3><p><strong>定义</strong><br>该运算符用于判断一个对象是否属于属于一个类或者实现了一个接口，结果为true或false。在强制类型转换之前通过<strong>instanceof</strong>运算符检查对象的真实类型，在进行相应的强制类型转换，这样就可以避免类型转换异常，从而提高代码的健壮性。</p>
<p><strong>用 instanceof 运算符</strong>： instanceof 通常和强制类型转换结合使用   判断对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象  <span class="keyword">instanceof</span>  类或接口	</span><br></pre></td></tr></table></figure>

<p>在进行强制引用类型转换时，先通过<strong>instanceof</strong>运算符进行类型判断，再进行相应的强制类型转换，这样可以有效地避免出现类型转换异常。</p>
<h2 id="3-实现多态的3个条件"><a href="#3-实现多态的3个条件" class="headerlink" title="3.实现多态的3个条件"></a>3.实现多态的3个条件</h2><ul>
<li>继承的存在（继承是多态的基础，没有继承就没有多态）。</li>
<li>子类重写父类的方法（多态下调用子类重写后的方法）。</li>
<li>父类引用变量指向子类对象（子类到父类的类型转换）。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510367.png" alt="第三章 多态"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第八章 File I/O</title>
    <url>/2021/06/04/%E7%AC%AC%E5%85%AB%E7%AB%A0%20File%20IO/</url>
    <content><![CDATA[<h1 id="第八章-File-I-O"><a href="#第八章-File-I-O" class="headerlink" title="第八章 File I/O"></a>第八章 File I/O</h1><h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h2><p>操作文件和文件夹</p>
<span id="more"></span>

<h2 id="File类常用方法"><a href="#File类常用方法" class="headerlink" title="File类常用方法"></a>File类常用方法</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean exists( )</strong></td>
<td>判断文件或目录是否存在</td>
</tr>
<tr>
<td><strong>boolean isFile( )</strong></td>
<td>判断是否是文件</td>
</tr>
<tr>
<td><strong>boolean isDirectory( )</strong></td>
<td>判断是否是目录</td>
</tr>
<tr>
<td><strong>String getPath( )</strong></td>
<td>返回此对象表示的文件的相对路径名</td>
</tr>
<tr>
<td><strong>String getAbsolutePath( )</strong></td>
<td>返回此对象表示的文件的绝对路径名</td>
</tr>
<tr>
<td><strong>String getName( )</strong></td>
<td>返回此对象表示的文件或目录的名称</td>
</tr>
<tr>
<td><strong>boolean delete( )</strong></td>
<td>删除此对象指定的文件或目录</td>
</tr>
<tr>
<td><strong>boolean createNewFile( )</strong></td>
<td>创建名称的空文件，不创建文件夹</td>
</tr>
<tr>
<td><strong>long length()</strong></td>
<td>返回文件的长度，单位为字节, 如果文件不存在，则返回 0L</td>
</tr>
</tbody></table>
<!--more-->

<h2 id="2-FileInputStream-字节流的写入-不能用于中文"><a href="#2-FileInputStream-字节流的写入-不能用于中文" class="headerlink" title="2. FileInputStream 字节流的写入    不能用于中文"></a>2. FileInputStream 字节流的写入    不能用于中文</h2><h3 id="InputStream-常用方法"><a href="#InputStream-常用方法" class="headerlink" title="InputStream 常用方法"></a>InputStream 常用方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>int reader()</strong></td>
<td>读取一个字节数据</td>
</tr>
<tr>
<td><strong>int reader( byte [] b)</strong></td>
<td>将数据读取到字节数组中</td>
</tr>
<tr>
<td><strong>int reader( byte [] b , int off . int len)</strong></td>
<td>从输入刘中读取最多 <strong>len</strong> 长度的字节，保存到字节数组 <strong>b</strong> 中，保存的位置从 <strong>off</strong> 开始</td>
</tr>
<tr>
<td><strong>void close()</strong></td>
<td>关闭输入流</td>
</tr>
<tr>
<td><strong>int available()</strong></td>
<td>返回输入流读取的估计字节数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;写入的路径&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;文件的大小&quot;</span> + fis.available());</span><br><span class="line">		<span class="keyword">int</span> date;</span><br><span class="line">		<span class="keyword">while</span> ((date = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println((<span class="keyword">char</span>) date); <span class="comment">//循环打印</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis.close();<span class="comment">//关闭处理报错</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">			e2.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-FileOutputStream-字节流的读取-不能用于中文"><a href="#3-FileOutputStream-字节流的读取-不能用于中文" class="headerlink" title="3. FileOutputStream 字节流的读取    不能用于中文"></a>3. FileOutputStream 字节流的读取    不能用于中文</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>void write(int c)</strong></td>
<td>写入一个字节数据</td>
</tr>
<tr>
<td><strong>void write(byte[] buf)</strong></td>
<td>写入数组 <strong>buf</strong> 的所有字节</td>
</tr>
<tr>
<td><strong>void write(byte[] buf，int off ，int len)</strong></td>
<td>将字节数组中从 <strong>off</strong> 位置开始，长度为 <strong>len</strong> 的字节数据输出到输出流中</td>
</tr>
<tr>
<td><strong>void close()</strong></td>
<td>关闭输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		fos=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;读取的路径&quot;</span>);</span><br><span class="line">		String s=<span class="string">&quot;需要写入的字符串&quot;</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] bs=s.getBytes();<span class="comment">//转成byte</span></span><br><span class="line">		fos.write(bs); <span class="comment">//写入文件</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fos.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">			e2.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-FileReader-字符流的读取-可以用于中文"><a href="#4-FileReader-字符流的读取-可以用于中文" class="headerlink" title="4. FileReader 字符流的读取  可以用于中文"></a>4. FileReader 字符流的读取  可以用于中文</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int read()</strong></td>
<td>从输入流中读取单个字符</td>
</tr>
<tr>
<td><strong>int read( byte[] c )</strong></td>
<td>从输入流中读取 <strong>c.length</strong> 长度的字符，保存到字符数组 <strong>c</strong> 中，返回实际读取的字符数</td>
</tr>
<tr>
<td><strong>int read(cahr[] c , int off , int len)</strong></td>
<td>从输入流中读取最多 <strong>len</strong> 的长度字符，保存到字符数组 <strong>c</strong> 中，保存的位置从 <strong>off</strong> 位置开始，返回时间读取的字符长度</td>
</tr>
<tr>
<td><strong>void close()</strong></td>
<td>关闭流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;读取路径&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> temp;</span><br><span class="line">		<span class="keyword">while</span> ((temp=fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println((<span class="keyword">char</span>)temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">	fr.close();		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">			e2.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-FileWrite-字符流的写入-可以用于中文"><a href="#5-FileWrite-字符流的写入-可以用于中文" class="headerlink" title="5.FileWrite 字符流的写入  可以用于中文"></a>5.FileWrite 字符流的写入  可以用于中文</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>write(String str)</strong></td>
<td>将 <strong>str</strong> 字符串里包含的字符输出到制定的输出流</td>
</tr>
<tr>
<td><strong>write(String str , int off ,int len)</strong></td>
<td>将 <strong>str</strong> 字符串里从 <strong>off</strong> 位置开始长度为<strong>len</strong> 的字符输出到输入流中</td>
</tr>
<tr>
<td><strong>void close()</strong></td>
<td>关闭输出流</td>
</tr>
<tr>
<td><strong>void flush()</strong></td>
<td>刷新输出流</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fw=<span class="keyword">new</span> FileWriter(<span class="string">&quot;写入的路径&quot;</span>);</span><br><span class="line">			fw.write(<span class="string">&quot;需要输出的文章&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">		fw.close();		</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-DataOutputStream-amp-amp-DataInputStream-数据缓存"><a href="#6-DataOutputStream-amp-amp-DataInputStream-数据缓存" class="headerlink" title="6.DataOutputStream &amp;&amp; DataInputStream 数据缓存"></a>6.DataOutputStream &amp;&amp; DataInputStream 数据缓存</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">		DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">		DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;读取文件&quot;</span>);</span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line">			fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;写入的文件&quot;</span>);</span><br><span class="line">			dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">			<span class="keyword">int</span> date;</span><br><span class="line">			<span class="keyword">while</span> ((date = dis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				dos.write(date);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				fis.close();</span><br><span class="line">				dis.close();</span><br><span class="line">				fos.close();</span><br><span class="line">				dos.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510925.png" alt="第八章 File IO总结"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 集合框架</title>
    <url>/2021/06/04/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="1-为什么使用集合框架"><a href="#1-为什么使用集合框架" class="headerlink" title="1.为什么使用集合框架"></a>1.为什么使用集合框架</h2><ul>
<li>数组长度固定不变，不能很好地适应元素数量动态变化的情况。</li>
<li>课通过数组名**.length**获取数组的长度，取无法直接获取数组中真实存储的个数。</li>
<li>数组采用在内存中分配连续空间的存储方式，根据下标可以快速获取对应的信息，但根据信息查找时效率低下，需要多次比较。在进行频繁插入、删除操作时同样效率低下<span id="more"></span></li>
</ul>
<h2 id="2-Java集合框架包含的内容"><a href="#2-Java集合框架包含的内容" class="headerlink" title="2.Java集合框架包含的内容"></a>2.Java集合框架包含的内容</h2><p>集合框架是为表示和操作借还而规定的一种统一的标准结构体系。集合框架都包含三大块内容：对外的接口，接口的实现和对集合运算的算法。</p>
<ul>
<li>接口：表示集合的抽象类数据类型。</li>
<li>实现：集合框架中接口的具体实现。</li>
<li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法</li>
</ul>
<p>Java集合框架中的两大类的接口：<strong>Collection</strong> 和 <strong>Map</strong> 。</p>
<ul>
<li><strong>Collection</strong> 接口可以存储一组不唯一，无序的对象<ul>
<li> <strong>Set</strong> 接口继承 <strong>Collection</strong> 接口，存储一组唯一、无序的对象。</li>
<li> <strong>List</strong> 接口继承 <strong>Collection</strong> 接口，存储一组不唯一、有序的对象</li>
</ul>
</li>
<li> <strong>Map</strong> 接口存储一组成对的键-值对象，提供 <strong>key（键）</strong> 到 <strong>value（值）</strong> 的映射。<strong>Map</strong> 中的 <strong>key</strong> 不要求有序，不允许重复。 <strong>value</strong> 同样不要求有序，但运行重复。</li>
<li> <strong>lterator</strong> 接口负责定义访问和遍历元素的接口。</li>
</ul>
<p><img src="/2021/06/04/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/img%5Cimage-20210528165408509.png" alt="image-20210528165408509"></p>
<h2 id="3-List接口"><a href="#3-List接口" class="headerlink" title="3.List接口"></a>3.List接口</h2><ul>
<li>实现List接口的常用类有 <strong>ArrayList</strong> 和 <strong>LinkedList</strong> 。他们都可以容纳所有类型的对象，包括null，允许重复，并且都包子元素的存储顺序。</li>
</ul>
<p>（1）LinkedList采用链表存储方式，有点在与插入，删除元素是效率比较高。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addFirst(Object o)</td>
<td>在列表的首部添加元素</td>
</tr>
<tr>
<td>void addLast(Object o)</td>
<td>在列表的末尾添加元素</td>
</tr>
<tr>
<td>Object getFirst()</td>
<td>返回列表中的第一个元素</td>
</tr>
<tr>
<td>Object getLast()</td>
<td>返回列表中的最后一个元素</td>
</tr>
<tr>
<td>Object removeFirst()</td>
<td>删除并返回列表中的第一个元素</td>
</tr>
<tr>
<td>Object removeLast()</td>
<td>删除并返回列表中的最后一个元素</td>
</tr>
</tbody></table>
<p>（2）ArrayList集合类</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean</strong> <strong>add(Object o)</strong></td>
<td>在列表的末尾顺序添加元素，起始索引位置从0开始</td>
</tr>
<tr>
<td><strong>void add(int index,Object o)</strong></td>
<td>在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间</td>
</tr>
<tr>
<td><strong>int size()</strong></td>
<td>返回列表中的元素个数</td>
</tr>
<tr>
<td><strong>Object get(int index)</strong></td>
<td>返回指定索引位置处的元素。取出的元素是Object类型，使用前需要进行强制类型转换</td>
</tr>
<tr>
<td><strong>boolean contains(Object o)</strong></td>
<td>判断列表中是否存在指定元素</td>
</tr>
<tr>
<td><strong>boolean remove(Object o)</strong></td>
<td>从列表中删除元素</td>
</tr>
<tr>
<td><strong>Object remove(int index)</strong></td>
<td>从列表中删除指定位置元素，起始索引位置从0开始</td>
</tr>
</tbody></table>
<p>List接口的 <strong>add(Object o)</strong> 方法的参数类型是 <strong>Object</strong> ，即使在调用时形参是插入时的类型，但系统认为是 <strong>Object</strong> ，所以在 <strong>get()</strong> 获取必需强转。</p>
<h3 id="4-Map接口"><a href="#4-Map接口" class="headerlink" title="4.Map接口"></a>4.Map接口</h3><h4 id="1-Map接口常用方法"><a href="#1-Map接口常用方法" class="headerlink" title="1.Map接口常用方法"></a>1.Map接口常用方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Object put(Object key, Object val)</strong></td>
<td>以“键-值对”的方式进行存储</td>
</tr>
<tr>
<td><strong>Object get (Object key)</strong></td>
<td>根据键返回相关联的值，如果不存在指定的键，返回null</td>
</tr>
<tr>
<td><strong>Object remove (Object key)</strong></td>
<td>删除由指定的键映射的“键-值对”</td>
</tr>
<tr>
<td><strong>int size()</strong></td>
<td>返回元素个数</td>
</tr>
<tr>
<td><strong>Set keySet ()</strong></td>
<td>返回键的集合</td>
</tr>
<tr>
<td><strong>Collection values ()</strong></td>
<td>返回值的集合</td>
</tr>
<tr>
<td><strong>boolean containsKey (Object key)</strong></td>
<td>如果存在由指定的键映射的“键-值对”，返回true</td>
</tr>
</tbody></table>
<h4 id="2-迭代器Iterator"><a href="#2-迭代器Iterator" class="headerlink" title="2.迭代器Iterator"></a>2.迭代器Iterator</h4><p><strong>Collection</strong> 接口的iterator()方法返回一个 <strong>Iterator</strong> ，然后通过 <strong>Iterator</strong> 接口的两个方法即可方便的实现遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">//判断是否存在另一个可访问的元素</span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span></span>;	   <span class="comment">//返回要访问的下一个元素</span></span><br></pre></td></tr></table></figure>

<p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型t  元素变量x : 数组或集合对象)&#123;</span><br><span class="line">         引用了x的java语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-泛型集合"><a href="#5-泛型集合" class="headerlink" title="5.泛型集合"></a>5.泛型集合</h4><p>如何解决以下强制类型转换时容易出现的异常问题?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>方法获取元素</span></span><br><span class="line"><span class="function">Map <span class="title">get</span><span class="params">(Object key)</span>方法获取元素</span></span><br><span class="line"><span class="function">Iterator <span class="title">next</span><span class="params">()</span>方法获取元素</span></span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510202.png" alt="第六章 集合框架"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 接口</title>
    <url>/2021/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="一、什么是接口？"><a href="#一、什么是接口？" class="headerlink" title="一、什么是接口？"></a>一、什么是接口？</h2><p>接口同样是哟中规范和标准，题目可以约束类的行为，是一些方法特征的集合，但是没有方法的实现。</p>
<p>接口可以看做一种特殊的“抽象类”，但是差异与抽象类万千不同的语法来表示，两者的设计观念也是不同的，抽象类利用与代码复用，接口利于代码的扩展和维护</p>
<span id="more"></span>

<h2 id="二、接口的语法"><a href="#二、接口的语法" class="headerlink" title="二、接口的语法"></a>二、接口的语法</h2><p>​    <strong>定义接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1，父接口2，·········</span>&#123;</span><br><span class="line">    	<span class="comment">//常量定义</span></span><br><span class="line">    	<span class="comment">//方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名 <span class="keyword">implements</span> 接口1，接口2，······</span>&#123;</span><br><span class="line">    	<span class="comment">//类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口定义的规则："><a href="#接口定义的规则：" class="headerlink" title="接口定义的规则："></a>接口定义的规则：</h4><ul>
<li><p>接口的命名规则与类相同。如果修饰符是public，则该接口在整个项目中可见；如果是省略修饰符，则该接口只在当前包可见。</p>
</li>
<li><p>接口中可以定义常量，不能定义变量。接口中的属性都会自动用 <strong>public static final</strong> 修饰，即接口中的属性都是全局静态常量。接口中的常量必须在定义时制定初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PI=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> PI=<span class="number">3.14</span>;	<span class="comment">//在接口中，这两个定义语句效果完全相同</span></span><br><span class="line"><span class="keyword">int</span> PI;			<span class="comment">//错误！在接口中必须制定初始值，在类中会有默认值</span></span><br></pre></td></tr></table></figure></li>
<li><p>接口中所有的方法都是抽象方法。接口中的方法都会自动用 <strong>public abstract</strong> 修饰，即接口中只有全局抽象方法。</p>
</li>
<li><p>和抽象类一样，接口也不能实例化，接口不中不能有构造方法。</p>
</li>
<li><p>接口之间可以通过 <strong>extends</strong> 实现继承关系，一个接口可以继承多个接口，但接口不能继承类。</p>
</li>
<li><p>接口的实际类必须实现接口的全部方法，否则必须定义为抽象类。</p>
</li>
</ul>
<h2 id="三、接口表示一种能力：体现在接口的方法上"><a href="#三、接口表示一种能力：体现在接口的方法上" class="headerlink" title="三、接口表示一种能力：体现在接口的方法上"></a>三、接口表示一种能力：体现在接口的方法上</h2><p>关心实现类有何能力，而不关心实现细节<br>面向接口的约定而不考虑接口的具体实现</p>
<h2 id="四、面向接口编程"><a href="#四、面向接口编程" class="headerlink" title="四、面向接口编程"></a>四、面向接口编程</h2><p>​    在面向对象编程中提倡面向接口编程，而不是面向实现编程。</p>
<p>​    接口体现了约定和实现相分离的原则，通过面向接口编程，可以降低代码间的耦合性，提高代码的可扩展性，面向接口编程就意味着开发系统时，主题结构使用接口，接口构成系统的股价，这样就可以通过更换实现接口的类来实现更换系统</p>
<p>​    面向接口编程可以实现接口和实现的分离，这样做最大的好处就是能够在客户端位置的情况下进行修改代码。</p>
<p>​    良好的接口定义一定是来自于需求的，它绝对不是程序员绞尽脑汁想出来的</p>
<h2 id="五、在C-中使用接口"><a href="#五、在C-中使用接口" class="headerlink" title="五、在C#中使用接口"></a>五、在C#中使用接口</h2><p>​    C#的接口语法和java相似</p>
<p>​    <strong>定义接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名： 父接口 1，父接口 2，······&#123;</span><br><span class="line">    属性定义</span><br><span class="line">    方法定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名：父类名，接口1，接口2······&#123;		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口区别"><a href="#接口区别" class="headerlink" title="接口区别"></a>接口区别</h4><ul>
<li>java中接口通过 <strong>extends</strong> 来继承接口，类通过 <strong>implements</strong> 来实现接口；C#中通过冒号 “ ： ” 来实现这两个功能</li>
<li>java接口中的成员变量（属性）都是常量，自动用 <strong>public static final</strong> 修饰；C#接口中不允许存在成员变量，但可以有属性。</li>
<li>java接口中的属性和方法都可以使用 <strong>public</strong> 修饰；C#中默认用 <strong>public</strong> ，但不允许显式使用 <strong>public</strong> 修饰</li>
<li>java接口中可以定义静态常量和方法，C#接口中不允许包括任何静态成员</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><img src="https://olinimg.oss-cn-shanghai.aliyuncs.com/HexoImg/202205131510898.png" alt="第四章 接口"></p>
]]></content>
      <categories>
        <category>使用Java实现面向对象编程整理</category>
      </categories>
  </entry>
</search>
